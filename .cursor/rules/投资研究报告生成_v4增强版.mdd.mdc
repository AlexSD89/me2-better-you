# 投资研究报告生成引擎规则 (v4.2-思维链图优化版)

> **核心功能**：本规则指导AI自动生成高质量投资研究报告，基于思维链图启示优化v4机制，通过"价值创造+风险控制+时间价值"三大支柱，确保分析深度、逻辑严密、可操作性强。

> **核心设计理念**：
> - 基于思维链图启示：A[核心逻辑] → B[风险控制] → C[增长潜力]
> - 简化执行步骤：从7步复杂流程优化为3步核心流程
> - 价值创造导向：每个步骤都有明确的价值创造目标
> - 网状思维架构：支持跳跃式思考和动态更新
> - 保留您的专属经验细节（权威信源、时间控制、质量要求等）

## 【核心设计理念：唯一确定的文件】

### 核心文件：Plan_Todo管理
- **作用**：记录、思考、更新的中心枢纽
- **特点**：边做边更新，动态生成
- **功能**：跟踪执行状态，记录思考过程，更新下一步计划
- **其他文件**：基于Plan_Todo管理的状态动态生成

### Plan_Todo管理文件结构
```
# 🔄 [专题名称] - 动态Plan_Todo管理系统

---
文件ID：📋00_[专题名称]_Plan_Todo管理
上游驱动：[用户请求]
下游驱动：[等待下一个文件生成]
状态码：#0001
生成时间：YYYY-MM-DD HH:MM
---

## 🎯 当前状态：[当前阶段]

### 核心原则确认
- ✅ **边做边更新**：每个文件都是动态生成的，不是预设的
- ✅ **价值驱动**：从价值发现开始，驱动分析流程
- ✅ **动态plan**：基于current_thinking动态生成plan
- ✅ **软性收敛**：在适当时机进行收敛判断
- ✅ **跳跃式思考**：支持文件动态更新和网状逻辑链

### 当前执行状态
- **阶段**：[当前阶段描述]
- **完成度**：[完成百分比]
- **状态**：[当前状态描述]

## 📋 动态Plan生成机制

### Plan生成规则
1. **基于current_thinking**：每个plan都基于当前的思考状态生成
2. **动态调整**：根据分析进展动态调整plan内容
3. **软性收敛判断**：每个阶段后进行收敛判断
4. **跳跃式更新**：支持文件间的动态更新和交叉验证

### 当前Plan状态
```
Plan 1：[阶段名称] ✅ 已完成/🔄 进行中/⏳ 准备中
- 生成文件：[文件名]
- 核心发现：[核心发现内容]
- 评分：[评分]

Plan 2：[阶段名称] ✅ 已完成/🔄 进行中/⏳ 准备中
- 目标：[目标描述]
- 重点：[重点内容]
- 状态：[状态描述]
```

## 🔄 动态跳转路径记录

### 思维跳转路径图
```mermaid
graph TD
    A[01_发现] --> B[02_思考]
    B --> C[03_假设]
    C --> D[04_验证]
    D --> E[05_反证]
    E --> F[06_结论]
    F --> G[07_交付]
    
    %% 跳跃式跳转（边做边生成）
    A --> D
    B --> E
    C --> F
```

### 当前跳转状态
```
启动 → [当前文件] → [等待下一个文件生成]
```

### 动态跳转规则
- **节点动态生成**：根据实际分析内容动态生成节点
- **连接动态建立**：根据思维跳转动态建立连接
- **路径动态更新**：每次分析进展都实时更新跳转路径

### 跳跃式跳转设计
- **[文件1] → [文件4]**：[跳跃原因]
- **[文件2] → [文件5]**：[跳跃原因]
- **[文件3] → [文件6]**：[跳跃原因]

### 智能推荐机制
基于当前分析状态，智能推荐下一步跳转：
- **[条件1]**：推荐跳到[阶段]
- **[条件2]**：推荐跳到[阶段]
- **[条件3]**：推荐跳到[阶段]

## 📊 执行进度监控

### 总体进度
- **完成度**：[百分比] ([已完成文件数]/[总文件数] 文件)
- **当前阶段**：[阶段名称]
- **状态**：[状态描述]

### 质量指标
- **权威信源覆盖度**：[百分比] ✅ (基于权威信源)
- **分析深度**：[百分比] ✅ (分析内容描述)
- **结论可操作性**：[百分比] ✅ (可操作性描述)
- **[其他指标]**：待评估

## 🎯 下一步行动

### 立即执行
1. ✅ **[已完成任务1]**
2. ✅ **[已完成任务2]**
3. 🔄 **[进行中任务]**
4. 🔄 **[准备中任务]**

### 动态更新机制
- 每次生成新文件时，自动更新本管理文件
- 每次完成分析阶段时，进行软性收敛判断
- 每次有新的发现时，动态调整后续plan

---
**文件状态**：[当前状态]
**下一步**：[下一步行动]
**更新时间**：YYYY-MM-DD HH:MM
```

## 【自动化执行步骤 - 基于Plan_Todo管理的动态流程】

**核心设定**：
- **思维链图支柱**：A[核心逻辑] → 价值创造
- **时间控制**：5分钟内自动完成
- **价值创造目标**：识别核心价值创造机会，构建核心逻辑框架
- **自动化执行**：无人工干预，自动推进到风险控制阶段
- **质量要求**：权威信源覆盖度>80%，价值发现准确性>90%

**核心逻辑架构设计**：
```
A[核心逻辑] → 非股权投资模式 → 保持100%控制权 → 专注产品发展
  ↓
价值创造：识别2,450亿美元市场机会，设计15%收入分成模式
```

**执行命令**：
**执行命令**：
```python
def value_discovery_and_core_logic(analysis_request):
    # 目标：识别核心价值创造机会，构建核心逻辑框架
    # 自动化：无人工干预，5分钟内自动完成
    start_time = get_current_time()
    
    if not analysis_request:
        return {"status": "REQUEST_MISSING", "action": "REQUEST_TOPIC"}
    
    # 自动价值识别和分解
    value_analysis = {
        "core_value": extract_core_value(analysis_request),  # 自动提取核心价值
        "market_opportunity": auto_identify_market_opportunity(analysis_request),  # 自动识别市场机会
        "value_creation_model": auto_determine_value_model(analysis_request),  # 自动确定价值创造模式
        "authority_requirements": auto_set_authority_requirements()  # 自动设置权威信源要求
    }
    
    # 自动价值发现计划生成和执行
    value_discovery_plan = [
        {
            "task": "自动识别核心价值创造机会",
            "target": "确保价值发现准确，符合投资逻辑",
            "automation": "基于权威信源自动识别价值机会",
            "time_allocation": "2分钟",
            "quality_check": "价值发现准确性>90%",
            "auto_trigger": "价值识别完成后自动构建核心逻辑"
        },
        {
            "task": "自动构建核心逻辑框架",
            "target": "确保逻辑框架清晰，可操作性强",
            "automation": "基于思维链图自动构建逻辑框架",
            "time_allocation": "2分钟",
            "quality_check": "逻辑框架完整性>85%",
            "auto_trigger": "逻辑构建完成后自动生成价值发现文件"
        },
        {
            "task": "自动生成价值发现文件",
            "target": "为后续风险控制做准备，确保价值导向明确",
            "automation": "自动生成价值发现文件",
            "time_allocation": "1分钟",
            "quality_check": "价值导向明确性>90%",
            "auto_trigger": "文件生成后自动推进到风险控制阶段"
        }
    ]
    
    # 自动执行价值发现计划
    for step in value_discovery_plan:
        result = auto_execute_value_step(step)
        if result["status"] == "success":
            auto_advance_to_next_value_step(step)
        else:
            auto_retry_or_skip_value_step(step)
    
    # 自动生成价值发现文件
    value_discovery_file = auto_create_value_discovery_file(analysis_request, value_analysis)
    
    # 自动推进到风险控制阶段
    if elapsed_time(start_time) > 5:
        force_complete_value_discovery()
    
    # 自动生成下一步TODO
    next_todo = auto_generate_risk_control_todo(value_discovery_file)
    
    return {
        "status": "VALUE_DISCOVERY_COMPLETED",
        "value_analysis": value_analysis,
        "value_discovery_plan": value_discovery_plan,
        "value_discovery_file": value_discovery_file,
        "next_todo": next_todo,
        "auto_advance": "READY_FOR_RISK_CONTROL"
    }
```

**AI必须执行**：
1. 检查分析请求是否有效
2. 自动识别核心价值创造机会
3. 构建基于思维链图的核心逻辑框架
4. 生成价值发现文件（文件作为价值节点）
5. 支持文件动态更新（新的价值发现更新到任何文件）
6. 标注文件头部逻辑链关系

### 步骤2：风险控制与验证机制 (RISK_CONTROL_AND_VALIDATION)

**核心设定**：
- **思维链图支柱**：B[风险控制] → 风险平衡
- **时间控制**：5分钟内自动完成
- **风险控制目标**：识别风险，建立控制机制，进行验证
- **自动化执行**：无人工干预，自动推进到增长优化阶段
- **质量要求**：风险识别覆盖度>90%，控制机制有效性>85%

**风险控制架构设计**：
```
B[风险控制] → 避免高利贷 → 避免非法集资 → 资金定向使用
  ↓
风险平衡：建立共管账户机制，实现1.5倍封顶保护
```

**执行命令**：

**执行命令**：
```python
def risk_control_and_validation(analysis_request):
    # 目标：识别风险，建立控制机制，进行验证
    # 自动化：无人工干预，5分钟内自动完成
    start_time = get_current_time()
    
    # 自动风险识别和控制系统
    risk_control_system = {
        "risk_identification": {
            "auto_risk_categories": ["合规风险", "市场风险", "技术风险", "运营风险"],
            "auto_risk_assessment": "自动评估风险等级和影响程度",
            "auto_risk_prioritization": "自动按优先级排序风险"
        },
        "control_mechanism": {
            "auto_control_design": "自动设计风险控制措施",
            "auto_control_validation": "自动验证控制措施有效性",
            "auto_control_monitoring": "自动建立风险监控机制"
        },
        "validation_process": {
            "auto_evidence_collection": "自动收集验证证据",
            "auto_validation_analysis": "自动分析验证结果",
            "auto_validation_reporting": "自动生成验证报告"
        }
    }
    
    # 自动风险控制执行计划
    risk_control_execution = [
        {
            "task": "自动识别核心风险点",
            "target": "确保风险识别全面，符合投资逻辑",
            "automation": "基于权威信源自动识别风险点",
            "time_allocation": "2分钟",
            "quality_check": "风险识别覆盖度>90%",
            "auto_trigger": "风险识别完成后自动设计控制措施"
        },
        {
            "task": "自动设计风险控制机制",
            "target": "确保控制措施有效，可操作性强",
            "automation": "基于思维链图自动设计控制机制",
            "time_allocation": "2分钟",
            "quality_check": "控制机制有效性>85%",
            "auto_trigger": "控制设计完成后自动进行验证"
        },
        {
            "task": "自动进行风险验证",
            "target": "确保风险控制措施有效，验证结果可靠",
            "automation": "自动收集验证证据并分析结果",
            "time_allocation": "1分钟",
            "quality_check": "验证结果可靠性>90%",
            "auto_trigger": "验证完成后自动推进到增长优化阶段"
        }
    ]
    
    # 自动执行风险控制计划
    risk_control_results = {}
    for risk_step in risk_control_execution:
        result = auto_execute_risk_step(risk_step, risk_control_system)
        if result["status"] == "success":
            risk_control_results.update(result["data"])
            auto_advance_to_next_risk_step(risk_step)
        else:
            auto_retry_risk_step(risk_step)
    
    # 自动生成风险控制文件
    risk_control_file = auto_create_risk_control_file(analysis_request, risk_control_results)
    
    # 自动推进到增长优化阶段
    if elapsed_time(start_time) > 5:
        force_complete_risk_control()
    
    # 自动生成下一步TODO
    next_todo = auto_generate_growth_optimization_todo(risk_control_file)
    
    return {
        "status": "RISK_CONTROL_COMPLETED",
        "risk_control_results": risk_control_results,
        "risk_control_file": risk_control_file,
        "next_todo": next_todo,
        "auto_advance": "READY_FOR_GROWTH_OPTIMIZATION"
    }
```

**AI必须执行**：
1. 自动识别核心风险点（合规、市场、技术、运营风险）
2. 基于思维链图设计风险控制机制
3. 自动进行风险验证和证据收集
4. 生成风险控制文件（文件作为风险节点）
5. 支持文件动态更新（新的风险发现更新到任何文件）
6. 标注文件头部逻辑链关系

### 步骤4：动态Plan生成与网状文件流转 (DYNAMIC_PLAN_AND_NETWORK)

**核心设定**：
- **思维链图支柱**：网状思维架构 → 跳跃式思考
- **时间控制**：动态生成，无固定时间限制
- **动态Plan目标**：基于current_thinking动态生成plan，支持执行循环
- **网状流转目标**：支持跳跃式思考和文件动态更新
- **质量要求**：plan可执行性>90%，网状连接完整性>85%

**动态Plan架构设计**：
```
基于思维链图的简化plan格式：
current_thinking:
  - 核心价值发现
  - 风险识别结果  
  - 时间框架设定

plan:
  - task: 具体任务描述
    value_creation: 价值创造目标
    risk_control: 风险控制措施
    time_frame: 时间要求
    priority: high/medium/low
```

**网状文件流转架构设计**：
```
价值发现 → 风险控制 → 增长优化
    ↓         ↓         ↓
  直接跳到验证 → 直接跳到结论 → 直接跳到交付
```

**执行命令**：
```python
def dynamic_plan_and_network_generation(current_thinking, all_files):
    # 目标：基于current_thinking动态生成plan，支持网状文件流转
    # 自动化：动态生成，无固定时间限制
    start_time = get_current_time()
    
    # 动态plan生成引擎
    dynamic_plan_engine = {
        "current_analysis": {
            "auto_completion_assessment": "自动评估当前完成情况",
            "auto_gap_identification": "自动识别与目标的差距",
            "auto_priority_assignment": "自动分配任务优先级"
        },
        "plan_generation": {
            "auto_task_decomposition": "自动分解任务",
            "auto_dependency_mapping": "自动映射任务依赖关系",
            "auto_time_allocation": "自动分配时间"
        },
        "network_flow": {
            "auto_jump_detection": "自动检测跳跃式思考机会",
            "auto_file_update": "自动更新文件内容",
            "auto_connection_building": "自动建立文件间连接"
        }
    }
    
    # 动态plan生成执行
    dynamic_plan_execution = [
        {
            "task": "自动分析当前完成情况",
            "target": "准确评估当前分析进度和质量",
            "automation": "自动统计已完成的分析内容和质量指标",
            "time_allocation": "动态分配",
            "quality_check": "完成情况评估准确性>90%",
            "auto_trigger": "完成情况分析后自动识别目标差距"
        },
        {
            "task": "自动识别目标差距",
            "target": "明确识别与原始目标的差距",
            "automation": "自动对比当前结果与原始目标",
            "time_allocation": "动态分配",
            "quality_check": "差距识别准确性>95%",
            "auto_trigger": "差距识别后自动生成plan"
        },
        {
            "task": "自动生成动态plan",
            "target": "生成可执行的下一步计划",
            "automation": "自动分解任务、分配优先级、映射依赖关系",
            "time_allocation": "动态分配",
            "quality_check": "plan可执行性>90%",
            "auto_trigger": "plan生成后自动推进到执行阶段"
        },
        {
            "task": "自动建立网状文件流转",
            "target": "支持跳跃式思考和文件动态更新",
            "automation": "自动检测跳跃机会、更新文件、建立连接",
            "time_allocation": "动态分配",
            "quality_check": "网状连接完整性>85%",
            "auto_trigger": "网状流转建立后自动支持执行循环"
        }
    ]
    
    # 自动执行动态plan生成
    plan_results = {}
    for plan_step in dynamic_plan_execution:
        result = auto_execute_plan_step(plan_step, dynamic_plan_engine)
        if result["status"] == "success":
            plan_results.update(result["data"])
            auto_advance_to_next_plan_step(plan_step)
        else:
            auto_retry_plan_step(plan_step)
    
    # 自动生成动态plan
    dynamic_generated_plan = []
    for gap in plan_results.get("goal_gaps", []):
        dynamic_generated_plan.append({
            "task": gap["task"],
            "value_creation": gap.get("value_creation", "N/A"),
            "risk_control": gap.get("risk_control", "N/A"),
            "time_frame": gap.get("time_frame", "N/A"),
            "priority": gap.get("priority", "medium"),
            "dependencies": gap.get("dependencies", [])
        })
    
    # 自动建立网状文件流转
    network_flow_results = auto_build_network_flow(all_files, current_thinking)
    
    return {
        "status": "DYNAMIC_PLAN_AND_NETWORK_GENERATED",
        "current_thinking": plan_results.get("current_thinking", []),
        "plan": dynamic_generated_plan,
        "network_flow": network_flow_results,
        "auto_advance": "READY_FOR_EXECUTION_LOOP"
    }
```

**AI必须执行**：
1. 基于current_thinking动态生成plan
2. 支持plan动态调整，允许分支、合并、回溯
3. 建立网状文件流转，支持跳跃式思考
4. 支持文件动态更新和交叉验证
5. 实现plan → execute → update → new plan的循环
6. 输出YAML/JSON格式，便于自动化追踪

### 步骤5：软性收敛判断 (SOFT_CONVERGENCE_CHECK)

**核心设定**：
- **思维链图支柱**：软性收敛机制 → 价值产出判断
- **时间控制**：动态判断，无固定时间限制
- **收敛判断目标**：自动判断分析是否达到收敛条件，决定是否继续或结束
- **自动化执行**：无人工干预，自动判断，自动决定下一步行动
- **质量要求**：收敛判断准确性>90%，价值产出评估完整性>85%

**软性收敛架构设计**：
```
软性收敛判断标准：
1. 假设验证收敛：主要假设已被多轮证据充分验证或反驳
2. 数据覆盖收敛：关键数据已收集完整，权威报告已充分引用
3. 逻辑链条收敛：发现之间的逻辑关系已清晰，多维度交叉验证已完成
4. 价值产出收敛：已形成可操作的结论，投资启示已明确
```

**执行命令**：
```python
def soft_convergence_check(all_files, current_thinking):
    # 目标：自动判断分析是否达到收敛条件
    # 自动化：无人工干预，自动判断，自动决定下一步行动
    start_time = get_current_time()
    
    # 软性收敛判断引擎
    soft_convergence_engine = {
        "convergence_criteria_check": {
            "auto_authority_coverage": "自动检查权威信源覆盖度",
            "auto_hypothesis_validation": "自动检查主要假设验证状态",
            "auto_controversy_resolution": "自动检查关键争议点解决状态",
            "auto_conclusion_quality": "自动检查结论质量",
            "auto_new_info_value": "自动评估新信息价值"
        },
        "convergence_decision": {
            "auto_convergence_trigger": "自动触发收敛判断",
            "auto_continue_trigger": "自动触发继续分析",
            "auto_force_convergence": "自动强制收敛（时间/数量限制）"
        }
    }
    
    # 软性收敛判断执行
    soft_convergence_execution = [
        {
            "task": "自动检查权威信源覆盖度",
            "target": "确保权威信源观点已充分覆盖",
            "automation": "自动统计权威信源覆盖率和质量",
            "time_allocation": "动态分配",
            "quality_check": "权威信源覆盖度>80%",
            "auto_trigger": "覆盖度检查完成后自动检查假设验证"
        },
        {
            "task": "自动检查主要假设验证状态",
            "target": "确保主要假设已充分验证或反驳",
            "automation": "自动评估每个假设的验证状态",
            "time_allocation": "动态分配",
            "quality_check": "主要假设验证率>90%",
            "auto_trigger": "假设验证检查完成后自动检查争议解决"
        },
        {
            "task": "自动检查关键争议点解决状态",
            "target": "确保关键争议点已有明确结论",
            "automation": "自动评估争议点的解决程度",
            "time_allocation": "动态分配",
            "quality_check": "关键争议点解决率>85%",
            "auto_trigger": "争议解决检查完成后自动检查结论质量"
        },
        {
            "task": "自动检查结论质量",
            "target": "确保已形成可操作的结论",
            "automation": "自动评估结论的可操作性和完整性",
            "time_allocation": "动态分配",
            "quality_check": "结论可操作性>80%",
            "auto_trigger": "结论质量检查完成后自动评估新信息价值"
        }
    ]
    
    # 自动执行软性收敛判断
    convergence_results = {}
    for convergence_step in soft_convergence_execution:
        result = auto_execute_convergence_step(convergence_step, soft_convergence_engine)
        if result["status"] == "success":
            convergence_results.update(result["data"])
            auto_advance_to_next_convergence_step(convergence_step)
        else:
            auto_retry_convergence_step(convergence_step)
    
    # 软性收敛决策
    if all(convergence_results.values()):
        auto_decision = "CONVERGED"
        auto_action = "GENERATE_FINAL_REPORT"
    else:
        auto_decision = "NOT_CONVERGED"
        auto_action = "CONTINUE_DISCOVERY"
    
    # 自动强制收敛检查
    if elapsed_time(start_time) > 15 or len(all_files) >= 5:
        auto_decision = "FORCE_CONVERGED"
        auto_action = "GENERATE_FINAL_REPORT"
    
    return {
        "status": auto_decision,
        "action": auto_action,
        "convergence_results": convergence_results,
        "auto_advance": "READY_FOR_DELIVERY" if auto_decision == "CONVERGED" else "CONTINUE_ANALYSIS"
    }
```

**AI必须执行**：
1. 检查收敛条件（权威信源覆盖度、假设验证状态、争议解决状态、结论质量）
2. 判断是否达到收敛条件
3. 决定下一步行动（继续分析或生成最终报告）
4. 支持强制收敛（时间/数量限制）
5. 自动推进到交付阶段或继续分析循环

### 步骤3：增长潜力与时间价值优化 (GROWTH_OPTIMIZATION)

**核心设定**：
- **思维链图支柱**：C[增长潜力] → 时间价值
- **时间控制**：5分钟内自动完成
- **增长优化目标**：设定增长目标，优化时间框架，形成可操作结论
- **自动化执行**：无人工干预，自动推进到软性收敛判断
- **质量要求**：增长目标可行性>85%，结论可操作性>80%

**增长潜力架构设计**：
```
C[增长潜力] → PMF/MVP聚焦 → MRR≥2万+媒体影响力 → 6-8个月目标
  ↓
时间价值：6-8个月实现MRR≥2万，建立媒体影响力
```

**执行命令**：

**执行命令**：
```python
def multi_angle_analysis(analysis_request):
    # 目标：自动进行深度分析，提炼核心洞察
    # 自动化：无人工干预，4分钟内自动完成
    start_time = get_current_time()
    
    # 自动分析引擎设置
    auto_analysis_engine = {
        "systematic_integration": {
            "auto_framework_selection": "自动选择最适合的分析框架",
            "auto_data_organization": "自动按框架组织数据",
            "auto_pattern_detection": "自动识别数据模式和趋势"
        },
        "critical_analysis": {
            "auto_pattern_recognition": "自动识别发展模式和驱动因素",
            "auto_causal_analysis": "自动分析因果关系和影响机制",
            "auto_comparative_analysis": "自动进行对比分析",
            "auto_insight_extraction": "自动提炼核心洞察"
        },
        "content_synthesis": {
            "auto_executive_summary": "自动生成执行摘要",
            "auto_main_analysis": "自动构建主要分析内容",
            "auto_conclusions": "自动形成结论",
            "auto_recommendations": "自动生成建议"
        }
    }
    
    # 自动分析执行计划
    auto_analysis_execution = [
        {
            "task": "自动执行批判性思维分析",
            "target": "超越信息罗列，提炼核心洞察，确保分析深度",
            "automation": "自动进行模式识别+因果分析+比较分析",
            "time_allocation": "2分钟",
            "quality_check": "分析深度>85%",
            "auto_trigger": "分析完成后自动构建逻辑链条"
        },
        {
            "task": "自动构建逻辑链条",
            "target": "确保论证过程逻辑严密，结论推导合理",
            "automation": "自动构建发现→思考→验证→结论的完整链条",
            "time_allocation": "1分钟",
            "quality_check": "逻辑链条完整性>95%",
            "auto_trigger": "逻辑链条构建后自动验证信源支撑"
        },
        {
            "task": "自动验证权威信源支撑",
            "target": "确保每个核心观点都有权威信源支撑",
            "automation": "自动检查每个关键结论的信源标注",
            "time_allocation": "1分钟",
            "quality_check": "权威信源支撑率>90%",
            "auto_trigger": "信源验证后自动提炼可操作结论"
        }
    ]
    
    # 自动执行分析计划
    analysis_results = {}
    for analysis_step in auto_analysis_execution:
        result = auto_execute_analysis_step(analysis_step, auto_analysis_engine)
        if result["status"] == "success":
            analysis_results.update(result["data"])
            auto_advance_to_next_analysis_step(analysis_step)
        else:
            auto_retry_analysis_step(analysis_step)
    
    # 自动创建分析文件
    analysis_file = auto_create_analysis_file(analysis_results, analysis_request)
    
    # 自动推进到下一个环节
    if elapsed_time(start_time) > 4:
        force_complete_analysis()
    
    # 自动生成下一步TODO
    next_todo = auto_generate_validation_todo(analysis_file)
    
    return {
        "status": "CONTENT_ANALYZED",
        "analysis_results": analysis_results,
        "analysis_file": analysis_file,
        "next_todo": next_todo,
        "auto_advance": "READY_FOR_VALIDATION"
    }
```

**AI必须执行**：
1. 系统性整合信息（您的专属经验）
2. 批判性思维与深度分析（您的专属经验）
3. 生成多面结论文件（每个角度独立文件）
4. 支持结论文件的动态更新和补充
5. 构建结论文件间的逻辑关系
6. 标注文件头部逻辑链关系

### 步骤4：动态验证与文件更新 (DYNAMIC_VALIDATION)
**目标**：自动收集权威信源证据，寻找反证，完善验证过程
**自动化执行**：无人工干预，3分钟内自动完成，自动推进到收敛判断

**执行命令**：
```python
def dynamic_validation(analysis_request):
    # 目标：自动收集权威信源证据，寻找反证
    # 自动化：无人工干预，3分钟内自动完成
    start_time = get_current_time()
    
    # 自动验证引擎设置
    auto_validation_engine = {
        "evidence_collection": {
            "auto_authority_search": "自动搜索权威信源证据",
            "auto_evidence_ranking": "自动按权威性排序证据",
            "auto_evidence_validation": "自动验证证据质量"
        },
        "counter_evidence_search": {
            "auto_counter_search": "自动搜索反证和局限性",
            "auto_counter_ranking": "自动按影响程度排序反证",
            "auto_counter_validation": "自动验证反证质量"
        },
        "validation_synthesis": {
            "auto_evidence_synthesis": "自动综合正面证据",
            "auto_counter_synthesis": "自动综合反证",
            "auto_balance_analysis": "自动进行平衡分析"
        }
    }
    
    # 自动验证执行计划
    auto_validation_execution = [
        {
            "task": "自动收集权威信源证据",
            "target": "确保每个观点都有权威信源支撑",
            "automation": "自动搜索Gartner/Forrester/McKinsey等权威报告",
            "time_allocation": "1.5分钟",
            "quality_check": "权威信源覆盖度>80%",
            "auto_trigger": "证据收集完成后自动寻找反证"
        },
        {
            "task": "自动寻找反证和局限性",
            "目标": "确保分析的客观性和完整性",
            "automation": "自动搜索失败案例、负面数据、专家质疑",
            "time_allocation": "1.5分钟",
            "quality_check": "反证分析完整性>90%",
            "auto_trigger": "反证分析完成后自动进行平衡分析"
        }
    ]
    
    # 自动执行验证计划
    validation_results = {}
    for validation_step in auto_validation_execution:
        result = auto_execute_validation_step(validation_step, auto_validation_engine)
        if result["status"] == "success":
            validation_results.update(result["data"])
            auto_advance_to_next_validation_step(validation_step)
        else:
            auto_retry_validation_step(validation_step)
    
    # 自动创建验证文件
    validation_file = auto_create_validation_file(validation_results, analysis_request)
    
    # 自动推进到下一个环节
    if elapsed_time(start_time) > 3:
        force_complete_validation()
    
    # 自动生成下一步TODO
    next_todo = auto_generate_convergence_todo(validation_file)
    
    return {
        "status": "VALIDATION_COMPLETED",
        "validation_results": validation_results,
        "validation_file": validation_file,
        "next_todo": next_todo,
        "auto_advance": "READY_FOR_CONVERGENCE"
    }
```

**AI必须执行**：
1. 收集权威信源证据
2. 寻找反证和局限性
3. 创建验证文件
4. 标注驱动关系

### 步骤5：软性收敛判断 (SOFT_CONVERGENCE_CHECK)
**目标**：自动判断分析是否达到收敛条件，决定是否继续或结束
**自动化执行**：无人工干预，自动判断，自动决定下一步行动

**执行命令**：
```python
def soft_convergence_check(all_files, current_thinking):
    # 目标：自动判断分析是否达到收敛条件
    # 自动化：无人工干预，自动判断，自动决定下一步行动
    start_time = get_current_time()
    
    # 软性收敛判断引擎
    soft_convergence_engine = {
        "convergence_criteria_check": {
            "auto_authority_coverage": "自动检查权威信源覆盖度",
            "auto_hypothesis_validation": "自动检查主要假设验证状态",
            "auto_controversy_resolution": "自动检查关键争议点解决状态",
            "auto_conclusion_quality": "自动检查结论质量",
            "auto_new_info_value": "自动评估新信息价值"
        },
        "convergence_decision": {
            "auto_convergence_trigger": "自动触发收敛判断",
            "auto_continue_trigger": "自动触发继续分析",
            "auto_force_convergence": "自动强制收敛（时间/数量限制）"
        }
    }
    
    # 软性收敛判断执行
    soft_convergence_execution = [
        {
            "task": "自动检查权威信源覆盖度",
            "target": "确保权威信源观点已充分覆盖",
            "automation": "自动统计权威信源覆盖率和质量",
            "time_allocation": "0.5分钟",
            "quality_check": "权威信源覆盖度>80%",
            "auto_trigger": "覆盖度检查完成后自动检查假设验证"
        },
        {
            "task": "自动检查主要假设验证状态",
            "target": "确保主要假设已充分验证或反驳",
            "automation": "自动评估每个假设的验证状态",
            "time_allocation": "0.5分钟",
            "quality_check": "主要假设验证率>90%",
            "auto_trigger": "假设验证检查完成后自动检查争议解决"
        },
        {
            "task": "自动检查关键争议点解决状态",
            "target": "确保关键争议点已有明确结论",
            "automation": "自动评估争议点的解决程度",
            "time_allocation": "0.5分钟",
            "quality_check": "关键争议点解决率>85%",
            "auto_trigger": "争议解决检查完成后自动检查结论质量"
        },
        {
            "task": "自动检查结论质量",
            "target": "确保已形成可操作的结论",
            "automation": "自动评估结论的可操作性和完整性",
            "time_allocation": "0.5分钟",
            "quality_check": "结论可操作性>80%",
            "auto_trigger": "结论质量检查完成后自动评估新信息价值"
        }
    ]
    
    # 自动执行软性收敛判断
    convergence_results = {}
    for convergence_step in soft_convergence_execution:
        result = auto_execute_convergence_step(convergence_step, soft_convergence_engine)
        if result["status"] == "success":
            convergence_results.update(result["data"])
            auto_advance_to_next_convergence_step(convergence_step)
        else:
            auto_retry_convergence_step(convergence_step)
    
    # 软性收敛决策
    if all(convergence_results.values()):
        auto_decision = "CONVERGED"
        auto_action = "GENERATE_FINAL_REPORT"
    else:
        auto_decision = "NOT_CONVERGED"
        auto_action = "CONTINUE_DISCOVERY"
    
    # 自动强制收敛检查
    if elapsed_time(start_time) > 15 or len(all_files) >= 5:
        auto_decision = "FORCE_CONVERGED"
        auto_action = "GENERATE_FINAL_REPORT"
    
    return {
        "status": auto_decision,
        "action": auto_action,
        "convergence_results": convergence_results,
        "auto_advance": "READY_FOR_DELIVERY" if auto_decision == "CONVERGED" else "CONTINUE_ANALYSIS"
    }
```

**AI必须执行**：
1. 检查收敛条件
2. 判断是否收敛
3. 决定下一步行动

### 步骤6：动态plan生成与执行 (DYNAMIC_PLAN_GENERATION)
**目标**：基于current_thinking动态生成plan，支持执行循环和软性收敛
**自动化执行**：无人工干预，自动生成，自动推进到执行阶段

**执行命令**：
```python
def dynamic_plan_generation(current_thinking, original_goal, analysis_results):
    # 目标：基于current_thinking动态生成plan，支持执行循环
    # 自动化：无人工干预，自动生成，自动推进到执行阶段
    start_time = get_current_time()
    
    # 动态plan生成引擎
    dynamic_plan_engine = {
        "current_analysis": {
            "auto_completion_assessment": "自动评估当前完成情况",
            "auto_gap_identification": "自动识别与目标的差距",
            "auto_priority_assignment": "自动分配任务优先级"
        },
        "plan_generation": {
            "auto_task_decomposition": "自动分解任务",
            "auto_dependency_mapping": "自动映射任务依赖关系",
            "auto_time_allocation": "自动分配时间"
        },
        "quality_assurance": {
            "auto_authority_check": "自动检查权威信源覆盖度",
            "auto_time_compliance": "自动检查时间限制合规性",
            "auto_depth_verification": "自动验证分析深度"
        }
    }
    
    # 动态plan生成执行
    dynamic_plan_execution = [
        {
            "task": "自动分析当前完成情况",
            "target": "准确评估当前分析进度和质量",
            "automation": "自动统计已完成的分析内容和质量指标",
            "time_allocation": "0.5分钟",
            "quality_check": "完成情况评估准确性>90%",
            "auto_trigger": "完成情况分析后自动识别目标差距"
        },
        {
            "task": "自动识别目标差距",
            "target": "明确识别与原始目标的差距",
            "automation": "自动对比当前结果与原始目标",
            "time_allocation": "0.5分钟",
            "quality_check": "差距识别准确性>95%",
            "auto_trigger": "差距识别后自动生成plan"
        },
        {
            "task": "自动生成动态plan",
            "target": "生成可执行的下一步计划",
            "automation": "自动分解任务、分配优先级、映射依赖关系",
            "time_allocation": "1分钟",
            "quality_check": "plan可执行性>90%",
            "auto_trigger": "plan生成后自动推进到执行阶段"
        }
    ]
    
    # 自动执行动态plan生成
    plan_results = {}
    for plan_step in dynamic_plan_execution:
        result = auto_execute_plan_step(plan_step, dynamic_plan_engine)
        if result["status"] == "success":
            plan_results.update(result["data"])
            auto_advance_to_next_plan_step(plan_step)
        else:
            auto_retry_plan_step(plan_step)
    
    # 自动生成动态plan
    dynamic_generated_plan = []
    for gap in plan_results.get("goal_gaps", []):
        dynamic_generated_plan.append({
            "task": gap["task"],
            "reason": gap["reason"],
            "priority": gap["priority"],
            "dependencies": gap.get("dependencies", []),
            "time_allocation": gap.get("time_allocation", "N/A"),
            "quality_check": gap.get("quality_check", "N/A"),
            "auto_trigger": gap.get("auto_trigger", "N/A")
        })
    
    # 自动质量保证检查
    auto_quality_assurance = {
        "authority_sources_coverage": "自动检查权威信源覆盖度",
        "time_limit_compliance": "自动检查15分钟时间限制合规性", 
        "analysis_depth_verification": "自动验证分析深度",
        "conclusion_operability": "自动验证结论可操作性",
        "format_compliance": "自动检查格式规范"
    }
    
    return {
        "status": "DYNAMIC_PLAN_GENERATED", 
        "current_thinking": plan_results.get("current_thinking", []),
        "plan": dynamic_generated_plan,
        "quality_assurance": auto_quality_assurance,
        "auto_advance": "READY_FOR_EXECUTION"
    }
```

**AI必须执行**：
1. 分析当前完成情况，输出current_thinking
2. 识别与目标的差距，生成动态plan
3. plan条目包含task、reason、priority、dependencies等元信息
4. 支持plan动态调整，允许分支、合并、回溯
5. 输出YAML/JSON格式，便于自动化追踪

**格式示例（YAML）**：
```yaml
current_thinking:
  - 客服自动化ROI高，但AI在复杂情感交互上有短板
  - 数据处理自动化效率提升显著，适合大数据场景
  - 投资机构对平台型AI+BPO公司兴趣浓厚

plan:
  - task: 深入调研AI客服在情感识别方面的最新进展
    reason: 弥补AI客服短板，提升结论说服力
    priority: high
    dependencies: []
  - task: 对比分析数据处理与客服自动化的实际落地案例
    reason: 明确两者ROI和技术门槛的差异
    priority: medium
    dependencies: []
  - task: 汇总2024年投资机构在AI+BPO领域的最新投资案例
    reason: 补全投资趋势分析
    priority: medium
    dependencies: []
```

**执行循环伪代码**：
```python
while not converged:
    current_thinking = analyze_current_results()
    plan = generate_next_plan(current_thinking, goal)
    for todo in plan:
        result = execute_todo(todo)
        update_context(result)
    if check_convergence():
        break
```

**关键要求**：
- 必须实现真正的执行循环，不能线性执行
- 每执行一个todo后必须更新context
- 基于新context重新生成plan
- 直到达到收敛条件才停止循环

### 步骤7：执行动态plan (DYNAMIC_PLAN_EXECUTION)
**目标**：自动执行动态plan，按优先级排序，逐个完成，自动推进到下一阶段
**自动化执行**：无人工干预，自动执行，自动推进，自动错误处理

**执行命令**：
```python
def execute_dynamic_plan(dynamic_plan):
    # 目标：自动执行动态plan，按优先级排序，逐个完成
    # 自动化：无人工干预，自动执行，自动推进，自动错误处理
    start_time = get_current_time()
    
    # 动态plan执行引擎
    dynamic_execution_engine = {
        "plan_prioritization": {
            "auto_priority_sorting": "自动按优先级排序plan",
            "auto_dependency_resolution": "自动解析依赖关系",
            "auto_resource_allocation": "自动分配执行资源"
        },
        "execution_management": {
            "auto_task_execution": "自动执行具体任务",
            "auto_progress_tracking": "自动跟踪执行进度",
            "auto_status_updating": "自动更新任务状态"
        },
        "error_handling": {
            "auto_error_detection": "自动检测执行错误",
            "auto_error_recovery": "自动错误恢复",
            "auto_fallback_strategy": "自动降级策略"
        }
    }
    
    # 自动执行计划
    auto_execution_plan = [
        {
            "task": "自动按优先级排序plan",
            "target": "确保按重要性顺序执行任务",
            "automation": "自动分析任务优先级和依赖关系",
            "time_allocation": "0.5分钟",
            "quality_check": "排序准确性>95%",
            "auto_trigger": "排序完成后自动开始执行"
        },
        {
            "task": "自动逐个执行plan任务",
            "target": "高效完成所有计划任务",
            "automation": "自动执行不同类型的任务（分析/采集/验证等）",
            "time_allocation": "根据任务数量动态分配",
            "quality_check": "任务完成率>90%",
            "auto_trigger": "每个任务完成后自动执行下一个"
        },
        {
            "task": "自动错误处理和恢复",
            "target": "确保执行过程的稳定性和可靠性",
            "automation": "自动检测错误并执行恢复策略",
            "time_allocation": "错误处理时间不计入总时间",
            "quality_check": "错误恢复成功率>85%",
            "auto_trigger": "错误发生时自动触发处理"
        }
    ]
    
    # 自动执行动态plan
    sorted_plan = auto_sort_plan_by_priority(dynamic_plan)
    execution_results = []
    
    for plan_item in sorted_plan:
        # 自动执行单个plan任务
        result = auto_execute_single_plan_item(plan_item, dynamic_execution_engine)
        
        # 自动更新状态
        plan_item['status'] = 'completed' if result["status"] == "success" else 'failed'
        plan_item['result'] = result
        
        execution_results.append(result)
        
        # 自动错误处理
        if result["status"] == "error":
            auto_error_recovery(plan_item, dynamic_execution_engine)
    
    # 自动生成统一输出
    auto_unified_output = {
        "status": "SUCCESS" if all(r["status"] == "success" for r in execution_results) else "PARTIAL_SUCCESS",
        "step": "动态plan执行完成",
        "report_type": "自动识别的报告类型",
        "output_path": "knowledge/03_研究报告/[自动确定的子目录]/",
        "framework_applied": "自动选择的分析框架",
        "quality_metrics": {
            "information_completeness": "自动计算的完整性指标",
            "source_authority": "自动计算的权威性权重",
            "analysis_depth": "自动评估的分析深度",
            "structure_coherence": "自动检查的结构一致性"
        },
        "execution_summary": {
            "total_plan_items": len(sorted_plan),
            "completed_items": len([r for r in execution_results if r["status"] == "success"]),
            "failed_items": len([r for r in execution_results if r["status"] == "error"]),
            "execution_time": elapsed_time(start_time)
        },
        "auto_advance": "READY_FOR_NEXT_PHASE"
    }
    
    return {
        "status": "DYNAMIC_PLAN_COMPLETED", 
        "results": execution_results, 
        "unified_output": auto_unified_output,
        "auto_advance": "READY_FOR_DELIVERY"
    }
```

**AI必须执行**：
1. 按优先级排序plan
2. 逐个执行plan任务
3. 更新执行状态
4. 返回执行结果

---



---

## 【文件流转机制】

### 文件间逻辑驱动关系
```
发现 → 思考 → 假设 → 验证 → 反证 → 结论 → 新发现
  ↓      ↓      ↓      ↓      ↓      ↓      ↓
驱动思考  驱动假设  驱动验证  驱动反证  驱动结论  驱动行动  驱动新思考
```

### 每个文件必须包含
1. **文件头部链条标注**：
   ```
   ---
   文件ID：[序号]_[类型]_[具体内容]
   上游驱动：[上一个文件的ID和核心发现]
   下游驱动：[驱动下一个文件的问题/假设/发现]
   状态码：[#0001-#0006]
   生成时间：YYYY-MM-DD HH:MM
   ---
   ```
2. **核心内容结构**：
   - 发现/思考/验证/反证的具体内容
   - 权威信源支撑（必须标注信源）
   - 逻辑推导过程
   - 驱动下一个文件的明确指示
3. **质量检查**：
   - 每个观点都有权威信源支撑
   - 逻辑链条清晰完整
   - 驱动关系明确

---

## 【软性收敛与交付机制】

### 软性收敛判断标准
每轮"发现-思考-反证"后，需主动判断是否达到收敛条件：

1. **假设验证收敛**
   - 主要假设已被多轮证据充分验证或反驳
   - 关键争议点已有明确结论
   - 反证分析已覆盖主要质疑

2. **数据覆盖收敛**
   - 关键数据已收集完整
   - 权威报告已充分引用
   - 案例对比已全面分析

3. **逻辑链条收敛**
   - 发现之间的逻辑关系已清晰
   - 多维度交叉验证已完成
   - 结论推导过程已完整

4. **价值产出收敛**
   - 已形成可操作的结论
   - 投资启示已明确
   - 进一步发散无新增高价值信息

### 软性收敛执行机制
- **禁止跳步**：必须按顺序执行，不能跳过任何阶段
- **禁止主观推断**：每个结论必须有证据支撑
- **强制软性收敛判断**：每个阶段结束后必须判断是否收敛
- **支持跳跃式思考**：允许在适当时机进行跳跃式思考
- **支持文件动态更新**：允许根据新发现动态更新任何文件

---

## 【执行指令】

### 核心执行逻辑
```
当收到专题分析请求时，AI必须：

1. 立即启动发现驱动思维模式
2. 按照思考流转机制生成文件：
   - 从具体发现开始
   - 每个发现驱动下一个思考
   - 每个文件都有明确的逻辑驱动关系
3. 确保每个观点都有具体的数据、案例和权威来源支撑
4. 通过交叉验证和反证分析确保客观性
5. 在适当时机进行软性收敛判断
6. 基于current_thinking动态生成plan
7. 执行plan循环直到收敛
8. 最终形成可操作的结论和策略建议
```

---

> **AI执行确认**: 本规则文件为v4.2动态plan版，专注于动态plan机制、软性收敛判断和跳跃式思考，确保分析深度和收敛效率的平衡。

---

# 附录：v4.2动态plan大逻辑与设计理念（README）

## v4.2动态plan大逻辑

```
发现驱动 → 信息采集 → 深度分析 → 验证反证 → 软性收敛判断 → 动态plan生成 → 执行plan → 完成交付
```

- 每一步都自动推进、自动判断、自动生成下一步plan
- 所有plan、目标、自动化机制都融入每个执行步骤和伪代码中
- 用户只需输入需求，系统自动完成全流程

## 设计理念

- **无人工干预**：每个步骤自动完成，自动推进
- **智能决策**：系统自动做出最佳决策
- **动态优化**：根据执行效果自动调整策略
- **持续学习**：自动积累和复用经验
- **结构化输出**：每一步都输出结构化状态、plan、quality_check
- **软性收敛与交付**：自动判断收敛，自动归档交付 

---

## 【文件流转机制】

### 文件间逻辑驱动关系
```
发现 → 思考 → 假设 → 验证 → 反证 → 结论 → 新发现
  ↓      ↓      ↓      ↓      ↓      ↓      ↓
驱动思考  驱动假设  驱动验证  驱动反证  驱动结论  驱动行动  驱动新思考
```

### 每个文件必须包含
1. **文件头部链条标注**：
   ```
   ---
   文件ID：[序号]_[类型]_[具体内容]
   上游驱动：[上一个文件的ID和核心发现]
   下游驱动：[驱动下一个文件的问题/假设/发现]
   状态码：[#0001-#0006]
   生成时间：YYYY-MM-DD HH:MM
   ---
   ```
2. **核心内容结构**：
   - 发现/思考/验证/反证的具体内容
   - 权威信源支撑（必须标注信源）
   - 逻辑推导过程
   - 驱动下一个文件的明确指示
3. **质量检查**：
   - 每个观点都有权威信源支撑
   - 逻辑链条清晰完整
   - 驱动关系明确

---

## 【自动化执行原则 - 所有设定融入步骤中】

### 强制执行原则
1. **严格按照5个步骤执行**：不能跳步，不能主观推断
2. **每个文件都要有驱动关系**：上游驱动和下游驱动必须明确
3. **权威信源优先**：只采纳权威信源，其他仅作补充
4. **时间控制严格**：15分钟内必须完成或收敛
5. **质量保证**：每个观点都要有证据支撑
6. **动态plan机制**：基于current_thinking动态生成plan，支持执行循环
7. **软性收敛判断**：每轮分析后主动判断是否达到收敛条件
8. **跳跃式思考**：支持文件动态更新和网状逻辑链构建
9. **执行循环机制**：必须实现plan → execute → update → new plan的循环
10. **我们的专属要求**：
    - 权威信源覆盖度>80%
    - 分析深度>85%
    - 结论可操作性>80%
    - 时间分配精确到分钟
    - 质量检查贯穿全程

---

## 【执行指令 - 基于Plan_Todo管理的核心流程】

### 核心执行逻辑
```
当收到专题分析请求时，AI必须：

1. 立即创建Plan_Todo管理文件（唯一确定的文件）
2. 基于Plan_Todo管理文件的状态动态生成其他文件：
   - 01_发现_[专题名称]_[具体内容].md
   - 02_思考_[专题名称]_[具体内容].md
   - 03_假设_[专题名称]_[具体内容].md
   - 04_验证_[专题名称]_[具体内容].md
   - 05_反证_[专题名称]_[具体内容].md
   - 06_结论_[专题名称]_[具体内容].md
   - 07_交付_[专题名称]_[具体内容].md
3. 每次生成新文件时，自动更新Plan_Todo管理文件
4. 基于current_thinking动态调整下一步计划
5. 支持跳跃式思考和网状文件流转
6. 在适当时机进行软性收敛判断
7. 最终形成可操作的分析结论
```

### 核心原则
- **唯一确定的文件**：Plan_Todo管理文件是唯一确定的，其他文件都是动态生成的
- **边做边更新**：每次分析进展都实时更新Plan_Todo管理文件
- **动态生成**：基于当前状态动态生成下一步文件
- **跳跃式思考**：支持文件间的跳跃式跳转和网状连接
- **软性收敛**：在适当时机进行收敛判断

### 执行循环机制
```python
# 基于思维链图的执行循环
while not converged:
    # 1. 价值发现
    value_discovery = discover_core_value()
    
    # 2. 风险控制  
    risk_control = identify_and_control_risks()
    
    # 3. 增长优化
    growth_optimization = optimize_growth_potential()
    
    # 4. 动态plan生成
    dynamic_plan = generate_dynamic_plan()
    
    # 5. 软性收敛判断
    if check_convergence():
        break
```

### 网状文件流转机制
```
价值发现 → 风险控制 → 增长优化
    ↓         ↓         ↓
  直接跳到验证 → 直接跳到结论 → 直接跳到交付
```

---

## 【Jina + Tavily协作技术配置】

### 工具配置
```yaml
jina_ai_reader:
  api_endpoint: "https://r.jina.ai"
  api_key: "jina_6e538c6492f2444197ee64397d7a4ca5CyXFjgbwy_VQ1NT2iwbf5x6RvPYM"
  capabilities:
    - "深度内容提取"
    - "绕过反爬虫保护"
    - "保持原始格式"
    - "结构化数据输出"

tavily_mcp_server:
  api_endpoint: "https://api.tavily.com/search"
  api_key: "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"
  mcp_server: "https://mcp.tavily.com/mcp/?tavilyApiKey=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"
  capabilities:
    - "实时网络搜索"
    - "内容提取"
    - "网页爬取"
    - "市场动态验证"
```

### 协作流程示例
```python
# 示例：分析ProductHunt热门产品
def analyze_producthunt_product(product_url):
    # 第一阶段：Jina深度提取
    jina_data = jina_extract_content(product_url)
    
    # 第二阶段：Tavily实时验证
    product_name = extract_product_name(jina_data)
    tavily_data = tavily_search_market_data(product_name)
    
    # 第三阶段：数据融合
    combined_data = fuse_jina_tavily_data(jina_data, tavily_data)
    
    return combined_data
```

### 质量指标
- **数据完整性**：>90%（Jina提供深度内容，Tavily补充实时数据）
- **时效性**：实时验证（Tavily确保数据时效性）
- **准确性**：双重验证（Jina+Tavily交叉验证）
- **权威性**：权威信源优先（Jina提取权威报告，Tavily验证市场表现）

---

> **AI执行确认**: 本规则文件为v4.2思维链图优化版，专注于价值创造导向、风险控制机制和网状思维架构，确保分析深度和收敛效率的平衡。已集成Jina + Tavily协作能力，提升数据采集质量和投资分析效率。

---

# 附录：v4.2思维链图优化大逻辑与设计理念（README）

## v4.2思维链图优化大逻辑

```
价值发现 → 风险控制 → 增长优化 → 软性收敛判断 → 动态plan生成 → 执行plan → 完成交付
```

- 每一步都基于思维链图三大支柱：价值创造、风险控制、时间价值
- 所有plan、目标、自动化机制都融入每个执行步骤和伪代码中
- 用户只需输入需求，系统自动完成全流程

## 设计理念

- **价值创造导向**：每个步骤都有明确的价值创造目标
- **风险控制内置**：每个阶段都有风险识别和控制机制
- **网状思维架构**：支持跳跃式思考和动态更新
- **时间价值优化**：基于时间框架优化分析效率
- **结构化输出**：每一步都输出结构化状态、plan、quality_check
- **软性收敛与交付**：自动判断收敛，自动归档交付