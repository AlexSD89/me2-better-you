# 06_数据交互设计.md

> **zhilink-v3 数据交互设计规范**  
> **统一的API集成与状态管理系统**  
> **6角色AI协作数据流架构**

---

## 🎯 数据交互架构

### 🏗️ 整体架构概览

```typescript
// 数据层架构定义
interface DataArchitecture {
  sources: {
    api: RESTfulAPI | GraphQLAPI;
    websocket: RealtimeConnection;
    cache: LocalCache | RedisCache;
    storage: LocalStorage | SessionStorage;
  };
  
  management: {
    state: 'Zustand' | 'Redux' | 'Jotai';
    queries: 'TanStack Query' | 'SWR' | 'Apollo';
    forms: 'React Hook Form' | 'Formik';
    validation: 'Zod' | 'Yup' | 'Joi';
  };
  
  patterns: {
    optimistic: OptimisticUpdates;
    offline: OfflineSync;
    realtime: RealtimeSync;
    streaming: StreamingData;
  };
}
```

### 🌊 数据流设计原则

```typescript
// 数据流设计原则
const DATA_FLOW_PRINCIPLES = {
  unidirectional: '单向数据流，确保状态可预测',
  immutable: '不可变数据，避免意外修改',
  reactive: '响应式更新，UI自动同步数据变化',
  optimistic: '乐观更新，提升用户体验',
  resilient: '容错处理，优雅降级',
  performant: '性能优先，懒加载和缓存'
} as const;
```

---

## 📊 数据模型定义

### 核心业务实体
```typescript
// src/types/entities.ts

// 用户实体
export interface User {
  id: string;
  email: string;
  name: string;
  avatar?: string;
  role: 'buyer' | 'vendor' | 'distributor';
  company?: {
    id: string;
    name: string;
    industry: 'legal' | 'medical' | 'ecommerce';
    size: 'startup' | 'sme' | 'enterprise';
  };
  preferences: {
    language: string;
    timezone: string;
    currency: string;
    theme: 'dark' | 'light' | 'auto';
  };
  subscription: {
    plan: 'free' | 'pro' | 'enterprise';
    status: 'active' | 'cancelled' | 'past_due';
    currentPeriodEnd: Date;
  };
  createdAt: Date;
  updatedAt: Date;
}

// 产品实体
export interface Product {
  id: string;
  name: string;
  slug: string;
  description: string;
  longDescription?: string;
  type: 'workforce' | 'expert_module' | 'market_report';
  status: 'draft' | 'published' | 'archived';
  
  // 供应商信息
  vendor: {
    id: string;
    name: string;
    avatar: string;
    verified: boolean;
    rating: number;
  };
  
  // 基础信息
  category: string;
  tags: string[];
  industry: ('legal' | 'medical' | 'ecommerce')[];
  
  // 媒体资源
  media: {
    images: string[];
    videos?: string[];
    documents?: Array<{
      name: string;
      url: string;
      type: string;
    }>;
  };
  
  // 定价信息
  pricing: {
    model: 'subscription' | 'usage' | 'one_time';
    tiers: Array<{
      name: string;
      price: number;
      currency: string;
      unit?: string;
      features: string[];
      limits?: Record<string, number>;
    }>;
  };
  
  // 技术指标
  metrics: {
    accuracy?: number;
    responseTime?: string;
    throughput?: string;
    languages?: string[];
    availability?: number;
    compliance?: string[];
  };
  
  // 评价统计
  rating: {
    average: number;
    count: number;
    distribution: Record<1 | 2 | 3 | 4 | 5, number>;
  };
  
  // 使用统计
  stats: {
    views: number;
    favorites: number;
    purchases: number;
    activeUsers: number;
  };
  
  // 时间戳
  createdAt: Date;
  updatedAt: Date;
  publishedAt?: Date;
}

// 6角色分析会话
export interface AnalysisSession {
  id: string;
  userId: string;
  title: string;
  status: 'initializing' | 'analyzing' | 'completed' | 'failed';
  
  // 用户输入
  input: {
    content: string;
    attachments?: Array<{
      id: string;
      name: string;
      type: string;
      url: string;
      size: number;
    }>;
    context?: {
      industry?: string;
      company?: string;
      budget?: number;
      timeline?: string;
    };
  };
  
  // 6角色分析结果
  analysis: {
    [K in AgentRole]?: {
      status: 'pending' | 'analyzing' | 'completed' | 'failed';
      insights: string[];
      recommendations: string[];
      confidence: number;
      processingTime: number;
      startedAt?: Date;
      completedAt?: Date;
    };
  };
  
  // 综合结果
  synthesis: {
    summary: string;
    keyInsights: string[];
    recommendations: ProductRecommendation[];
    nextSteps: string[];
    confidence: number;
  };
  
  // 会话消息
  messages: ChatMessage[];
  
  // 时间戳
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
}

// AI角色定义
export type AgentRole = 'alex' | 'sarah' | 'mike' | 'emma' | 'david' | 'catherine';

export interface AgentInfo {
  id: AgentRole;
  name: string;
  role: string;
  description: string;
  expertise: string[];
  color: string;
  avatar: string;
}

// 产品推荐
export interface ProductRecommendation {
  product: Product;
  matchScore: number;
  reasons: string[];
  agentInsights: Partial<Record<AgentRole, string>>;
  pricing: {
    estimatedCost: number;
    costBreakdown: Array<{
      component: string;
      cost: number;
      period?: string;
    }>;
  };
  implementation: {
    complexity: 'low' | 'medium' | 'high';
    timeline: string;
    requirements: string[];
    risks: string[];
  };
}

// 订单实体
export interface Order {
  id: string;
  userId: string;
  status: 'pending' | 'processing' | 'completed' | 'cancelled' | 'refunded';
  
  items: Array<{
    productId: string;
    product: Product;
    quantity: number;
    unitPrice: number;
    totalPrice: number;
    configuration?: Record<string, any>;
  }>;
  
  totals: {
    subtotal: number;
    tax: number;
    discount: number;
    total: number;
    currency: string;
  };
  
  payment: {
    method: 'credit_card' | 'wire_transfer' | 'crypto';
    status: 'pending' | 'completed' | 'failed';
    transactionId?: string;
    paidAt?: Date;
  };
  
  delivery: {
    type: 'digital' | 'consultation' | 'integration';
    status: 'pending' | 'in_progress' | 'delivered';
    estimatedDate?: Date;
    deliveredAt?: Date;
  };
  
  createdAt: Date;
  updatedAt: Date;
}
```

### API响应包装类型
```typescript
// src/types/api.ts

// 统一API响应格式
export interface ApiResponse<T = any> {
  success: boolean;
  data: T;
  message?: string;
  timestamp: string;
  requestId: string;
}

// 分页响应格式
export interface PaginatedResponse<T> {
  items: T[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrevious: boolean;
  };
}

// 错误响应格式
export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, any>;
  field?: string;
  timestamp: string;
  requestId: string;
}

// WebSocket消息格式
export interface WebSocketMessage<T = any> {
  type: string;
  payload: T;
  timestamp: string;
  sessionId?: string;
}
```

---

## 🔌 API客户端设计

### 1. 基础API客户端
```typescript
// src/lib/api-client.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { ApiResponse, ApiError } from '@/types/api';

class ApiClient {
  private client: AxiosInstance;
  private baseURL: string;
  private authToken: string | null = null;
  
  constructor(baseURL: string) {
    this.baseURL = baseURL;
    this.client = axios.create({
      baseURL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    this.setupInterceptors();
  }
  
  private setupInterceptors() {
    // 请求拦截器
    this.client.interceptors.request.use(
      (config) => {
        // 添加认证头
        if (this.authToken) {
          config.headers.Authorization = `Bearer ${this.authToken}`;
        }
        
        // 添加请求ID用于追踪
        config.headers['X-Request-ID'] = this.generateRequestId();
        
        // 添加时间戳
        config.headers['X-Timestamp'] = new Date().toISOString();
        
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // 响应拦截器
    this.client.interceptors.response.use(
      (response: AxiosResponse<ApiResponse>) => {
        return response;
      },
      async (error) => {
        if (error.response?.status === 401) {
          // Token过期，尝试刷新
          await this.refreshToken();
          return this.client.request(error.config);
        }
        
        if (error.response?.status >= 500) {
          // 服务器错误，记录日志
          console.error('Server Error:', error.response.data);
        }
        
        return Promise.reject(this.handleApiError(error));
      }
    );
  }
  
  // 设置认证token
  setAuthToken(token: string) {
    this.authToken = token;
  }
  
  // 清除认证token
  clearAuthToken() {
    this.authToken = null;
  }
  
  // 刷新token
  private async refreshToken(): Promise<void> {
    try {
      const refreshToken = localStorage.getItem('refreshToken');
      if (!refreshToken) {
        throw new Error('No refresh token available');
      }
      
      const response = await axios.post(`${this.baseURL}/auth/refresh`, {
        refreshToken,
      });
      
      const { accessToken } = response.data.data;
      this.setAuthToken(accessToken);
      localStorage.setItem('accessToken', accessToken);
    } catch (error) {
      // 刷新失败，跳转到登录页
      this.clearAuthToken();
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      window.location.href = '/auth/login';
    }
  }
  
  // 通用GET方法
  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.get<ApiResponse<T>>(url, config);
    return response.data.data;
  }
  
  // 通用POST方法
  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.post<ApiResponse<T>>(url, data, config);
    return response.data.data;
  }
  
  // 通用PUT方法
  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.put<ApiResponse<T>>(url, data, config);
    return response.data.data;
  }
  
  // 通用DELETE方法
  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.delete<ApiResponse<T>>(url, config);
    return response.data.data;
  }
  
  // 文件上传
  async upload<T>(url: string, file: File, onProgress?: (progress: number) => void): Promise<T> {
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await this.client.post<ApiResponse<T>>(url, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          onProgress(progress);
        }
      },
    });
    
    return response.data.data;
  }
  
  // 错误处理
  private handleApiError(error: any): ApiError {
    if (error.response?.data) {
      return error.response.data;
    }
    
    return {
      code: 'NETWORK_ERROR',
      message: error.message || 'Network request failed',
      timestamp: new Date().toISOString(),
      requestId: this.generateRequestId(),
    };
  }
  
  // 生成请求ID
  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substring(7)}`;
  }
}

// 创建全局API客户端实例
export const apiClient = new ApiClient(process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api');
```

### 2. 业务API服务
```typescript
// src/services/products.ts
import { apiClient } from '@/lib/api-client';
import { Product, PaginatedResponse } from '@/types/entities';

export interface ProductFilters {
  type?: string[];
  category?: string[];
  industry?: string[];
  priceMin?: number;
  priceMax?: number;
  rating?: number;
  tags?: string[];
  verified?: boolean;
  search?: string;
}

export interface ProductsParams extends ProductFilters {
  page?: number;
  pageSize?: number;
  sort?: 'name' | 'rating' | 'price' | 'popularity' | 'newest';
  order?: 'asc' | 'desc';
}

class ProductService {
  // 获取产品列表
  async getProducts(params: ProductsParams = {}): Promise<PaginatedResponse<Product>> {
    return apiClient.get('/products', { params });
  }
  
  // 获取产品详情
  async getProduct(id: string): Promise<Product> {
    return apiClient.get(`/products/${id}`);
  }
  
  // 搜索产品
  async searchProducts(query: string, filters: ProductFilters = {}): Promise<PaginatedResponse<Product>> {
    return apiClient.post('/products/search', {
      query,
      filters,
    });
  }
  
  // 获取相关产品推荐
  async getRelatedProducts(productId: string): Promise<Product[]> {
    return apiClient.get(`/products/${productId}/related`);
  }
  
  // 获取热门产品
  async getPopularProducts(industry?: string): Promise<Product[]> {
    return apiClient.get('/products/popular', {
      params: { industry },
    });
  }
  
  // 添加到收藏
  async addToFavorites(productId: string): Promise<void> {
    return apiClient.post(`/products/${productId}/favorite`);
  }
  
  // 从收藏中移除
  async removeFromFavorites(productId: string): Promise<void> {
    return apiClient.delete(`/products/${productId}/favorite`);
  }
  
  // 获取用户收藏的产品
  async getFavoriteProducts(): Promise<PaginatedResponse<Product>> {
    return apiClient.get('/user/favorites');
  }
  
  // 提交产品评价
  async submitReview(productId: string, review: {
    rating: number;
    title: string;
    content: string;
    pros?: string[];
    cons?: string[];
  }): Promise<void> {
    return apiClient.post(`/products/${productId}/reviews`, review);
  }
  
  // 获取产品评价
  async getReviews(productId: string, page = 1): Promise<PaginatedResponse<any>> {
    return apiClient.get(`/products/${productId}/reviews`, {
      params: { page },
    });
  }
}

export const productService = new ProductService();
```

### 3. 6角色分析服务
```typescript
// src/services/analysis.ts
import { apiClient } from '@/lib/api-client';
import { AnalysisSession, ProductRecommendation } from '@/types/entities';

export interface AnalysisRequest {
  content: string;
  attachments?: File[];
  context?: {
    industry?: string;
    company?: string;
    budget?: number;
    timeline?: string;
    requirements?: string[];
  };
}

export interface AnalysisStreamEvent {
  type: 'agent_start' | 'agent_progress' | 'agent_complete' | 'synthesis_start' | 'synthesis_complete' | 'error';
  agent?: string;
  progress?: number;
  data?: any;
  error?: string;
}

class AnalysisService {
  // 启动6角色分析
  async startAnalysis(request: AnalysisRequest): Promise<AnalysisSession> {
    const formData = new FormData();
    formData.append('content', request.content);
    
    if (request.context) {
      formData.append('context', JSON.stringify(request.context));
    }
    
    if (request.attachments) {
      request.attachments.forEach((file, index) => {
        formData.append(`attachment_${index}`, file);
      });
    }
    
    return apiClient.post('/analysis/start', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
  }
  
  // 获取分析会话详情
  async getAnalysisSession(sessionId: string): Promise<AnalysisSession> {
    return apiClient.get(`/analysis/${sessionId}`);
  }
  
  // 获取用户的分析历史
  async getAnalysisHistory(): Promise<PaginatedResponse<AnalysisSession>> {
    return apiClient.get('/analysis/history');
  }
  
  // 获取基于分析的产品推荐
  async getRecommendations(sessionId: string): Promise<ProductRecommendation[]> {
    return apiClient.get(`/analysis/${sessionId}/recommendations`);
  }
  
  // 添加后续问题到分析会话
  async addFollowUpQuestion(sessionId: string, question: string): Promise<AnalysisSession> {
    return apiClient.post(`/analysis/${sessionId}/followup`, {
      question,
    });
  }
  
  // 导出分析报告
  async exportReport(sessionId: string, format: 'pdf' | 'docx'): Promise<Blob> {
    const response = await apiClient.client.get(`/analysis/${sessionId}/export`, {
      params: { format },
      responseType: 'blob',
    });
    
    return response.data;
  }
  
  // 分享分析会话
  async shareSession(sessionId: string, settings: {
    public: boolean;
    expireAt?: Date;
    password?: string;
  }): Promise<{ shareUrl: string }> {
    return apiClient.post(`/analysis/${sessionId}/share`, settings);
  }
  
  // 订阅分析进度 (WebSocket)
  subscribeToProgress(sessionId: string, onEvent: (event: AnalysisStreamEvent) => void): () => void {
    const ws = new WebSocket(`${process.env.NEXT_PUBLIC_WS_URL}/analysis/${sessionId}/stream`);
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      onEvent(data);
    };
    
    ws.onerror = (error) => {
      onEvent({
        type: 'error',
        error: 'WebSocket连接失败',
      });
    };
    
    // 返回取消订阅函数
    return () => {
      ws.close();
    };
  }
}

export const analysisService = new AnalysisService();
```

---

## 🗄️ 状态管理设计

### 1. 全局状态 (Zustand)
```typescript
// src/stores/auth.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { User } from '@/types/entities';
import { authService } from '@/services/auth';

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  
  // Actions
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  updateProfile: (updates: Partial<User>) => Promise<void>;
  refreshUser: () => Promise<void>;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      isAuthenticated: false,
      isLoading: false,
      
      login: async (email: string, password: string) => {
        set({ isLoading: true });
        
        try {
          const { user, tokens } = await authService.login(email, password);
          
          // 保存tokens
          localStorage.setItem('accessToken', tokens.accessToken);
          localStorage.setItem('refreshToken', tokens.refreshToken);
          
          // 设置API client token
          apiClient.setAuthToken(tokens.accessToken);
          
          set({
            user,
            isAuthenticated: true,
            isLoading: false,
          });
        } catch (error) {
          set({ isLoading: false });
          throw error;
        }
      },
      
      logout: () => {
        // 清除本地存储
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        
        // 清除API client token
        apiClient.clearAuthToken();
        
        set({
          user: null,
          isAuthenticated: false,
        });
      },
      
      updateProfile: async (updates: Partial<User>) => {
        const updatedUser = await authService.updateProfile(updates);
        
        set({
          user: updatedUser,
        });
      },
      
      refreshUser: async () => {
        try {
          const user = await authService.getCurrentUser();
          set({ user, isAuthenticated: true });
        } catch (error) {
          // 用户信息获取失败，可能token过期
          get().logout();
        }
      },
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);
```

### 2. 分析会话状态
```typescript
// src/stores/analysis.ts
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { AnalysisSession, ChatMessage, AgentRole } from '@/types/entities';
import { analysisService } from '@/services/analysis';

interface AnalysisState {
  currentSession: AnalysisSession | null;
  sessions: AnalysisSession[];
  isAnalyzing: boolean;
  activeAgents: AgentRole[];
  
  // Actions
  startAnalysis: (content: string, attachments?: File[]) => Promise<void>;
  addFollowUp: (question: string) => Promise<void>;
  loadSession: (sessionId: string) => Promise<void>;
  loadHistory: () => Promise<void>;
  clearCurrentSession: () => void;
  
  // Real-time updates
  updateAgentProgress: (agent: AgentRole, progress: number) => void;
  completeAgentAnalysis: (agent: AgentRole, result: any) => void;
}

export const useAnalysisStore = create<AnalysisState>()(
  subscribeWithSelector((set, get) => ({
    currentSession: null,
    sessions: [],
    isAnalyzing: false,
    activeAgents: [],
    
    startAnalysis: async (content: string, attachments?: File[]) => {
      set({ isAnalyzing: true, activeAgents: [] });
      
      try {
        const session = await analysisService.startAnalysis({
          content,
          attachments,
        });
        
        set({
          currentSession: session,
          isAnalyzing: true,
          activeAgents: ['alex'], // 首先激活Alex
        });
        
        // 订阅实时进度更新
        const unsubscribe = analysisService.subscribeToProgress(
          session.id,
          (event) => {
            const store = get();
            
            switch (event.type) {
              case 'agent_start':
                if (event.agent) {
                  store.updateAgentProgress(event.agent as AgentRole, 0);
                }
                break;
                
              case 'agent_progress':
                if (event.agent && typeof event.progress === 'number') {
                  store.updateAgentProgress(event.agent as AgentRole, event.progress);
                }
                break;
                
              case 'agent_complete':
                if (event.agent) {
                  store.completeAgentAnalysis(event.agent as AgentRole, event.data);
                }
                break;
                
              case 'synthesis_complete':
                set({
                  isAnalyzing: false,
                  activeAgents: [],
                  currentSession: {
                    ...store.currentSession!,
                    ...event.data,
                  },
                });
                unsubscribe();
                break;
                
              case 'error':
                set({ isAnalyzing: false, activeAgents: [] });
                unsubscribe();
                break;
            }
          }
        );
        
      } catch (error) {
        set({ isAnalyzing: false, activeAgents: [] });
        throw error;
      }
    },
    
    addFollowUp: async (question: string) => {
      const { currentSession } = get();
      if (!currentSession) return;
      
      const updatedSession = await analysisService.addFollowUpQuestion(
        currentSession.id,
        question
      );
      
      set({ currentSession: updatedSession });
    },
    
    loadSession: async (sessionId: string) => {
      const session = await analysisService.getAnalysisSession(sessionId);
      set({ currentSession: session });
    },
    
    loadHistory: async () => {
      const { items } = await analysisService.getAnalysisHistory();
      set({ sessions: items });
    },
    
    clearCurrentSession: () => {
      set({ currentSession: null, isAnalyzing: false, activeAgents: [] });
    },
    
    updateAgentProgress: (agent: AgentRole, progress: number) => {
      const { currentSession, activeAgents } = get();
      if (!currentSession) return;
      
      // 如果agent不在活跃列表中，添加它
      if (!activeAgents.includes(agent)) {
        set({ activeAgents: [...activeAgents, agent] });
      }
      
      set({
        currentSession: {
          ...currentSession,
          analysis: {
            ...currentSession.analysis,
            [agent]: {
              ...currentSession.analysis[agent],
              status: 'analyzing',
              // 可以添加进度字段
            },
          },
        },
      });
    },
    
    completeAgentAnalysis: (agent: AgentRole, result: any) => {
      const { currentSession, activeAgents } = get();
      if (!currentSession) return;
      
      set({
        currentSession: {
          ...currentSession,
          analysis: {
            ...currentSession.analysis,
            [agent]: {
              ...result,
              status: 'completed',
            },
          },
        },
        activeAgents: activeAgents.filter(a => a !== agent),
      });
    },
  }))
);
```

### 3. 服务器状态管理 (TanStack Query)
```typescript
// src/hooks/use-products.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { productService } from '@/services/products';
import { ProductsParams, ProductFilters } from '@/services/products';

// 产品列表查询
export const useProducts = (params: ProductsParams) => {
  return useQuery({
    queryKey: ['products', params],
    queryFn: () => productService.getProducts(params),
    staleTime: 5 * 60 * 1000, // 5分钟
    cacheTime: 30 * 60 * 1000, // 30分钟
    keepPreviousData: true,
  });
};

// 产品详情查询
export const useProduct = (productId: string) => {
  return useQuery({
    queryKey: ['product', productId],
    queryFn: () => productService.getProduct(productId),
    enabled: !!productId,
    staleTime: 10 * 60 * 1000, // 10分钟
    cacheTime: 60 * 60 * 1000, // 1小时
  });
};

// 产品搜索
export const useProductSearch = () => {
  return useMutation({
    mutationFn: ({ query, filters }: { query: string; filters?: ProductFilters }) =>
      productService.searchProducts(query, filters),
  });
};

// 收藏产品
export const useFavoriteProduct = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (productId: string) => productService.addToFavorites(productId),
    onSuccess: (_, productId) => {
      // 更新产品详情缓存
      queryClient.invalidateQueries(['product', productId]);
      // 更新收藏列表缓存
      queryClient.invalidateQueries(['user', 'favorites']);
    },
  });
};

// 取消收藏
export const useUnfavoriteProduct = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (productId: string) => productService.removeFromFavorites(productId),
    onSuccess: (_, productId) => {
      queryClient.invalidateQueries(['product', productId]);
      queryClient.invalidateQueries(['user', 'favorites']);
    },
  });
};

// 预加载相关产品
export const usePrefetchRelatedProducts = () => {
  const queryClient = useQueryClient();
  
  return (productId: string) => {
    queryClient.prefetchQuery({
      queryKey: ['products', 'related', productId],
      queryFn: () => productService.getRelatedProducts(productId),
      staleTime: 10 * 60 * 1000,
    });
  };
};
```

---

## ⚡ 实时数据同步

### 1. WebSocket管理器
```typescript
// src/lib/websocket.ts
import { WebSocketMessage } from '@/types/api';

interface WebSocketOptions {
  reconnectAttempts?: number;
  reconnectInterval?: number;
  heartbeatInterval?: number;
}

class WebSocketManager {
  private ws: WebSocket | null = null;
  private url: string;
  private options: Required<WebSocketOptions>;
  private reconnectCount = 0;
  private heartbeatTimer: NodeJS.Timeout | null = null;
  private eventHandlers: Map<string, Set<(data: any) => void>> = new Map();
  
  constructor(url: string, options: WebSocketOptions = {}) {
    this.url = url;
    this.options = {
      reconnectAttempts: 5,
      reconnectInterval: 5000,
      heartbeatInterval: 30000,
      ...options,
    };
  }
  
  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.ws = new WebSocket(this.url);
        
        this.ws.onopen = () => {
          console.log('WebSocket connected');
          this.reconnectCount = 0;
          this.startHeartbeat();
          resolve();
        };
        
        this.ws.onmessage = (event) => {
          try {
            const message: WebSocketMessage = JSON.parse(event.data);
            this.handleMessage(message);
          } catch (error) {
            console.error('Failed to parse WebSocket message:', error);
          }
        };
        
        this.ws.onclose = (event) => {
          console.log('WebSocket disconnected:', event.code, event.reason);
          this.stopHeartbeat();
          
          if (event.code !== 1000 && this.reconnectCount < this.options.reconnectAttempts) {
            setTimeout(() => this.reconnect(), this.options.reconnectInterval);
          }
        };
        
        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          reject(error);
        };
        
      } catch (error) {
        reject(error);
      }
    });
  }
  
  disconnect(): void {
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect');
      this.ws = null;
    }
    this.stopHeartbeat();
  }
  
  private async reconnect(): Promise<void> {
    this.reconnectCount++;
    console.log(`Attempting to reconnect (${this.reconnectCount}/${this.options.reconnectAttempts})`);
    
    try {
      await this.connect();
    } catch (error) {
      if (this.reconnectCount >= this.options.reconnectAttempts) {
        console.error('Max reconnection attempts reached');
        this.emit('connection_failed', { error });
      }
    }
  }
  
  private startHeartbeat(): void {
    this.heartbeatTimer = setInterval(() => {
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.send('ping', {});
      }
    }, this.options.heartbeatInterval);
  }
  
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  
  private handleMessage(message: WebSocketMessage): void {
    // 处理心跳响应
    if (message.type === 'pong') {
      return;
    }
    
    // 分发消息给对应的处理器
    this.emit(message.type, message.payload);
  }
  
  send(type: string, payload: any): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      const message: WebSocketMessage = {
        type,
        payload,
        timestamp: new Date().toISOString(),
      };
      
      this.ws.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket is not connected, message not sent:', type);
    }
  }
  
  on(eventType: string, handler: (data: any) => void): () => void {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set());
    }
    
    this.eventHandlers.get(eventType)!.add(handler);
    
    // 返回取消监听函数
    return () => {
      this.eventHandlers.get(eventType)?.delete(handler);
    };
  }
  
  private emit(eventType: string, data: any): void {
    const handlers = this.eventHandlers.get(eventType);
    if (handlers) {
      handlers.forEach((handler) => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Error in WebSocket event handler for ${eventType}:`, error);
        }
      });
    }
  }
  
  isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }
}

// 创建全局WebSocket实例
export const wsManager = new WebSocketManager(
  process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3000/ws'
);
```

### 2. 实时数据Hook
```typescript
// src/hooks/use-realtime.ts
import { useEffect, useRef } from 'react';
import { wsManager } from '@/lib/websocket';

export const useRealtimeAnalysis = (
  sessionId: string,
  onProgress: (event: any) => void
) => {
  const handlerRef = useRef(onProgress);
  
  // 更新处理器引用
  useEffect(() => {
    handlerRef.current = onProgress;
  }, [onProgress]);
  
  useEffect(() => {
    if (!sessionId) return;
    
    // 订阅分析进度事件
    const unsubscribe = wsManager.on(`analysis_progress_${sessionId}`, (data) => {
      handlerRef.current(data);
    });
    
    // 发送订阅请求
    wsManager.send('subscribe_analysis', { sessionId });
    
    return () => {
      // 取消订阅
      wsManager.send('unsubscribe_analysis', { sessionId });
      unsubscribe();
    };
  }, [sessionId]);
};

export const useRealtimeNotifications = (
  userId: string,
  onNotification: (notification: any) => void
) => {
  const handlerRef = useRef(onNotification);
  
  useEffect(() => {
    handlerRef.current = onNotification;
  }, [onNotification]);
  
  useEffect(() => {
    if (!userId) return;
    
    const unsubscribe = wsManager.on(`user_notification_${userId}`, (data) => {
      handlerRef.current(data);
    });
    
    wsManager.send('subscribe_notifications', { userId });
    
    return () => {
      wsManager.send('unsubscribe_notifications', { userId });
      unsubscribe();
    };
  }, [userId]);
};
```

---

## 💾 智能缓存策略

### 1. 缓存配置
```typescript
// src/lib/cache-config.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // 默认缓存时间：5分钟
      staleTime: 5 * 60 * 1000,
      // 内存中保留时间：30分钟
      cacheTime: 30 * 60 * 1000,
      // 重试配置
      retry: (failureCount, error: any) => {
        // 4xx错误不重试
        if (error?.response?.status >= 400 && error?.response?.status < 500) {
          return false;
        }
        return failureCount < 3;
      },
      // 重试延迟
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
    mutations: {
      retry: 1,
    },
  },
});

// 预加载策略
export const PREFETCH_STRATEGIES = {
  // 产品相关数据预加载
  products: {
    relatedProducts: 'hover', // 悬浮时预加载相关产品
    productDetails: 'click', // 点击时预加载详情
    vendorInfo: 'visible', // 可见时预加载供应商信息
  },
  
  // 用户数据预加载
  user: {
    preferences: 'login', // 登录时预加载偏好设置
    history: 'dashboard', // 进入仪表板时预加载历史
    favorites: 'market', // 进入市场时预加载收藏
  },
  
  // AI分析数据预加载
  analysis: {
    templates: 'chat', // 进入聊天时预加载模板
    history: 'dashboard', // 仪表板预加载历史分析
    recommendations: 'complete', // 分析完成时预加载推荐
  },
} as const;
```

### 2. 预测性缓存
```typescript
// src/hooks/use-predictive-cache.ts
import { useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { productService } from '@/services/products';

export const usePredictiveProductCache = () => {
  const queryClient = useQueryClient();
  
  // 基于用户行为预加载产品数据
  const prefetchProduct = (productId: string, priority: 'low' | 'high' = 'low') => {
    const prefetchOptions = {
      staleTime: 10 * 60 * 1000, // 10分钟
      cacheTime: 60 * 60 * 1000, // 1小时
    };
    
    // 预加载产品详情
    queryClient.prefetchQuery({
      queryKey: ['product', productId],
      queryFn: () => productService.getProduct(productId),
      ...prefetchOptions,
    });
    
    if (priority === 'high') {
      // 高优先级时，同时预加载相关产品
      queryClient.prefetchQuery({
        queryKey: ['products', 'related', productId],
        queryFn: () => productService.getRelatedProducts(productId),
        ...prefetchOptions,
      });
    }
  };
  
  // 基于浏览历史预测用户兴趣
  const prefetchByUserInterest = (viewedProducts: string[]) => {
    // 分析用户浏览的产品类型
    const productTypes = new Set();
    const industries = new Set();
    
    viewedProducts.forEach(productId => {
      // 从缓存中获取产品信息进行分析
      const cachedProduct = queryClient.getQueryData(['product', productId]);
      if (cachedProduct) {
        productTypes.add((cachedProduct as any).type);
        (cachedProduct as any).industry.forEach((ind: string) => industries.add(ind));
      }
    });
    
    // 预加载相似类型的热门产品
    Array.from(industries).forEach(industry => {
      queryClient.prefetchQuery({
        queryKey: ['products', 'popular', industry],
        queryFn: () => productService.getPopularProducts(industry as string),
        staleTime: 15 * 60 * 1000,
      });
    });
  };
  
  return {
    prefetchProduct,
    prefetchByUserInterest,
  };
};

// 智能缓存清理
export const useCacheOptimization = () => {
  const queryClient = useQueryClient();
  
  useEffect(() => {
    // 监听内存使用情况
    const checkMemoryUsage = () => {
      if ('memory' in performance) {
        const memInfo = (performance as any).memory;
        const usageRatio = memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit;
        
        // 如果内存使用率超过80%，主动清理缓存
        if (usageRatio > 0.8) {
          queryClient.clear();
          console.log('Cache cleared due to high memory usage');
        }
      }
    };
    
    const interval = setInterval(checkMemoryUsage, 30000); // 30秒检查一次
    
    return () => clearInterval(interval);
  }, [queryClient]);
  
  // 智能缓存失效
  const invalidateByUserAction = (action: string, context: any) => {
    switch (action) {
      case 'favorite_product':
        // 收藏产品后，失效相关缓存
        queryClient.invalidateQueries(['user', 'favorites']);
        queryClient.invalidateQueries(['product', context.productId]);
        break;
        
      case 'complete_analysis':
        // 完成分析后，预加载推荐产品
        if (context.recommendations) {
          context.recommendations.forEach((rec: any) => {
            queryClient.prefetchQuery({
              queryKey: ['product', rec.product.id],
              queryFn: () => productService.getProduct(rec.product.id),
            });
          });
        }
        break;
        
      case 'view_product':
        // 查看产品后，预测性加载相关内容
        queryClient.prefetchQuery({
          queryKey: ['products', 'related', context.productId],
          queryFn: () => productService.getRelatedProducts(context.productId),
        });
        break;
    }
  };
  
  return {
    invalidateByUserAction,
  };
};
```

---

## 📋 数据交互实现清单

### API客户端实现
- [ ] 基础HTTP客户端和拦截器
- [ ] 认证token管理和刷新机制
- [ ] 错误处理和重试策略
- [ ] 文件上传和进度跟踪
- [ ] 请求缓存和去重机制

### 业务服务实现
- [ ] 产品服务：CRUD操作和搜索
- [ ] 用户服务：认证和个人资料管理
- [ ] 分析服务：6角色AI协作接口
- [ ] 订单服务：购买流程和支付集成
- [ ] 通知服务：实时消息推送

### 状态管理实现
- [ ] 全局状态：用户认证和应用设置
- [ ] 业务状态：分析会话和产品数据
- [ ] 表单状态：复杂表单的状态管理
- [ ] 缓存状态：智能缓存策略实现
- [ ] 持久化状态：本地存储同步

### 实时通信实现
- [ ] WebSocket连接管理
- [ ] 断线重连和错误恢复
- [ ] 消息分发和事件处理
- [ ] 心跳检测和连接状态
- [ ] 频道订阅和取消机制

### 性能优化实现
- [ ] 预测性数据预加载
- [ ] 智能缓存失效策略
- [ ] 内存使用监控和清理
- [ ] 网络请求优化
- [ ] 批量操作和防抖处理

### 错误处理实现
- [ ] 全局错误边界和处理
- [ ] 网络错误恢复机制
- [ ] 用户友好的错误提示
- [ ] 错误日志和监控集成
- [ ] 降级策略和回退方案

---

**总结**: zhilink-v3的数据交互设计基于现代化的技术栈和最佳实践，通过类型安全的API客户端、智能的状态管理、实时的数据同步和预测性的缓存策略，为6角色AI协作系统提供了坚实的数据基础。这套架构不仅能够支持当前的业务需求，还为未来的功能扩展预留了充分的空间。

通过完整的6个设计文档，zhilink-v3项目现在拥有了从技术架构到数据交互的全方位指导，可以支持开发团队进行高效、规范的开发工作，确保最终产品能够实现预期的用户体验和业务目标。