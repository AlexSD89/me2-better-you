# 06_æ•°æ®äº¤äº’è®¾è®¡.md

> **zhilink-v3 æ•°æ®äº¤äº’è®¾è®¡è§„èŒƒ**  
> **ç»Ÿä¸€çš„APIé›†æˆä¸çŠ¶æ€ç®¡ç†ç³»ç»Ÿ**  
> **6è§’è‰²AIåä½œæ•°æ®æµæ¶æ„**

---

## ğŸ¯ æ•°æ®äº¤äº’æ¶æ„

### ğŸ—ï¸ æ•´ä½“æ¶æ„æ¦‚è§ˆ

```typescript
// æ•°æ®å±‚æ¶æ„å®šä¹‰
interface DataArchitecture {
  sources: {
    api: RESTfulAPI | GraphQLAPI;
    websocket: RealtimeConnection;
    cache: LocalCache | RedisCache;
    storage: LocalStorage | SessionStorage;
  };
  
  management: {
    state: 'Zustand' | 'Redux' | 'Jotai';
    queries: 'TanStack Query' | 'SWR' | 'Apollo';
    forms: 'React Hook Form' | 'Formik';
    validation: 'Zod' | 'Yup' | 'Joi';
  };
  
  patterns: {
    optimistic: OptimisticUpdates;
    offline: OfflineSync;
    realtime: RealtimeSync;
    streaming: StreamingData;
  };
}
```

### ğŸŒŠ æ•°æ®æµè®¾è®¡åŸåˆ™

```typescript
// æ•°æ®æµè®¾è®¡åŸåˆ™
const DATA_FLOW_PRINCIPLES = {
  unidirectional: 'å•å‘æ•°æ®æµï¼Œç¡®ä¿çŠ¶æ€å¯é¢„æµ‹',
  immutable: 'ä¸å¯å˜æ•°æ®ï¼Œé¿å…æ„å¤–ä¿®æ”¹',
  reactive: 'å“åº”å¼æ›´æ–°ï¼ŒUIè‡ªåŠ¨åŒæ­¥æ•°æ®å˜åŒ–',
  optimistic: 'ä¹è§‚æ›´æ–°ï¼Œæå‡ç”¨æˆ·ä½“éªŒ',
  resilient: 'å®¹é”™å¤„ç†ï¼Œä¼˜é›…é™çº§',
  performant: 'æ€§èƒ½ä¼˜å…ˆï¼Œæ‡’åŠ è½½å’Œç¼“å­˜'
} as const;
```

---

## ğŸ“Š æ•°æ®æ¨¡å‹å®šä¹‰

### æ ¸å¿ƒä¸šåŠ¡å®ä½“
```typescript
// src/types/entities.ts

// ç”¨æˆ·å®ä½“
export interface User {
  id: string;
  email: string;
  name: string;
  avatar?: string;
  role: 'buyer' | 'vendor' | 'distributor';
  company?: {
    id: string;
    name: string;
    industry: 'legal' | 'medical' | 'ecommerce';
    size: 'startup' | 'sme' | 'enterprise';
  };
  preferences: {
    language: string;
    timezone: string;
    currency: string;
    theme: 'dark' | 'light' | 'auto';
  };
  subscription: {
    plan: 'free' | 'pro' | 'enterprise';
    status: 'active' | 'cancelled' | 'past_due';
    currentPeriodEnd: Date;
  };
  createdAt: Date;
  updatedAt: Date;
}

// äº§å“å®ä½“
export interface Product {
  id: string;
  name: string;
  slug: string;
  description: string;
  longDescription?: string;
  type: 'workforce' | 'expert_module' | 'market_report';
  status: 'draft' | 'published' | 'archived';
  
  // ä¾›åº”å•†ä¿¡æ¯
  vendor: {
    id: string;
    name: string;
    avatar: string;
    verified: boolean;
    rating: number;
  };
  
  // åŸºç¡€ä¿¡æ¯
  category: string;
  tags: string[];
  industry: ('legal' | 'medical' | 'ecommerce')[];
  
  // åª’ä½“èµ„æº
  media: {
    images: string[];
    videos?: string[];
    documents?: Array<{
      name: string;
      url: string;
      type: string;
    }>;
  };
  
  // å®šä»·ä¿¡æ¯
  pricing: {
    model: 'subscription' | 'usage' | 'one_time';
    tiers: Array<{
      name: string;
      price: number;
      currency: string;
      unit?: string;
      features: string[];
      limits?: Record<string, number>;
    }>;
  };
  
  // æŠ€æœ¯æŒ‡æ ‡
  metrics: {
    accuracy?: number;
    responseTime?: string;
    throughput?: string;
    languages?: string[];
    availability?: number;
    compliance?: string[];
  };
  
  // è¯„ä»·ç»Ÿè®¡
  rating: {
    average: number;
    count: number;
    distribution: Record<1 | 2 | 3 | 4 | 5, number>;
  };
  
  // ä½¿ç”¨ç»Ÿè®¡
  stats: {
    views: number;
    favorites: number;
    purchases: number;
    activeUsers: number;
  };
  
  // æ—¶é—´æˆ³
  createdAt: Date;
  updatedAt: Date;
  publishedAt?: Date;
}

// 6è§’è‰²åˆ†æä¼šè¯
export interface AnalysisSession {
  id: string;
  userId: string;
  title: string;
  status: 'initializing' | 'analyzing' | 'completed' | 'failed';
  
  // ç”¨æˆ·è¾“å…¥
  input: {
    content: string;
    attachments?: Array<{
      id: string;
      name: string;
      type: string;
      url: string;
      size: number;
    }>;
    context?: {
      industry?: string;
      company?: string;
      budget?: number;
      timeline?: string;
    };
  };
  
  // 6è§’è‰²åˆ†æç»“æœ
  analysis: {
    [K in AgentRole]?: {
      status: 'pending' | 'analyzing' | 'completed' | 'failed';
      insights: string[];
      recommendations: string[];
      confidence: number;
      processingTime: number;
      startedAt?: Date;
      completedAt?: Date;
    };
  };
  
  // ç»¼åˆç»“æœ
  synthesis: {
    summary: string;
    keyInsights: string[];
    recommendations: ProductRecommendation[];
    nextSteps: string[];
    confidence: number;
  };
  
  // ä¼šè¯æ¶ˆæ¯
  messages: ChatMessage[];
  
  // æ—¶é—´æˆ³
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
}

// AIè§’è‰²å®šä¹‰
export type AgentRole = 'alex' | 'sarah' | 'mike' | 'emma' | 'david' | 'catherine';

export interface AgentInfo {
  id: AgentRole;
  name: string;
  role: string;
  description: string;
  expertise: string[];
  color: string;
  avatar: string;
}

// äº§å“æ¨è
export interface ProductRecommendation {
  product: Product;
  matchScore: number;
  reasons: string[];
  agentInsights: Partial<Record<AgentRole, string>>;
  pricing: {
    estimatedCost: number;
    costBreakdown: Array<{
      component: string;
      cost: number;
      period?: string;
    }>;
  };
  implementation: {
    complexity: 'low' | 'medium' | 'high';
    timeline: string;
    requirements: string[];
    risks: string[];
  };
}

// è®¢å•å®ä½“
export interface Order {
  id: string;
  userId: string;
  status: 'pending' | 'processing' | 'completed' | 'cancelled' | 'refunded';
  
  items: Array<{
    productId: string;
    product: Product;
    quantity: number;
    unitPrice: number;
    totalPrice: number;
    configuration?: Record<string, any>;
  }>;
  
  totals: {
    subtotal: number;
    tax: number;
    discount: number;
    total: number;
    currency: string;
  };
  
  payment: {
    method: 'credit_card' | 'wire_transfer' | 'crypto';
    status: 'pending' | 'completed' | 'failed';
    transactionId?: string;
    paidAt?: Date;
  };
  
  delivery: {
    type: 'digital' | 'consultation' | 'integration';
    status: 'pending' | 'in_progress' | 'delivered';
    estimatedDate?: Date;
    deliveredAt?: Date;
  };
  
  createdAt: Date;
  updatedAt: Date;
}
```

### APIå“åº”åŒ…è£…ç±»å‹
```typescript
// src/types/api.ts

// ç»Ÿä¸€APIå“åº”æ ¼å¼
export interface ApiResponse<T = any> {
  success: boolean;
  data: T;
  message?: string;
  timestamp: string;
  requestId: string;
}

// åˆ†é¡µå“åº”æ ¼å¼
export interface PaginatedResponse<T> {
  items: T[];
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrevious: boolean;
  };
}

// é”™è¯¯å“åº”æ ¼å¼
export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, any>;
  field?: string;
  timestamp: string;
  requestId: string;
}

// WebSocketæ¶ˆæ¯æ ¼å¼
export interface WebSocketMessage<T = any> {
  type: string;
  payload: T;
  timestamp: string;
  sessionId?: string;
}
```

---

## ğŸ”Œ APIå®¢æˆ·ç«¯è®¾è®¡

### 1. åŸºç¡€APIå®¢æˆ·ç«¯
```typescript
// src/lib/api-client.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { ApiResponse, ApiError } from '@/types/api';

class ApiClient {
  private client: AxiosInstance;
  private baseURL: string;
  private authToken: string | null = null;
  
  constructor(baseURL: string) {
    this.baseURL = baseURL;
    this.client = axios.create({
      baseURL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    this.setupInterceptors();
  }
  
  private setupInterceptors() {
    // è¯·æ±‚æ‹¦æˆªå™¨
    this.client.interceptors.request.use(
      (config) => {
        // æ·»åŠ è®¤è¯å¤´
        if (this.authToken) {
          config.headers.Authorization = `Bearer ${this.authToken}`;
        }
        
        // æ·»åŠ è¯·æ±‚IDç”¨äºè¿½è¸ª
        config.headers['X-Request-ID'] = this.generateRequestId();
        
        // æ·»åŠ æ—¶é—´æˆ³
        config.headers['X-Timestamp'] = new Date().toISOString();
        
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // å“åº”æ‹¦æˆªå™¨
    this.client.interceptors.response.use(
      (response: AxiosResponse<ApiResponse>) => {
        return response;
      },
      async (error) => {
        if (error.response?.status === 401) {
          // Tokenè¿‡æœŸï¼Œå°è¯•åˆ·æ–°
          await this.refreshToken();
          return this.client.request(error.config);
        }
        
        if (error.response?.status >= 500) {
          // æœåŠ¡å™¨é”™è¯¯ï¼Œè®°å½•æ—¥å¿—
          console.error('Server Error:', error.response.data);
        }
        
        return Promise.reject(this.handleApiError(error));
      }
    );
  }
  
  // è®¾ç½®è®¤è¯token
  setAuthToken(token: string) {
    this.authToken = token;
  }
  
  // æ¸…é™¤è®¤è¯token
  clearAuthToken() {
    this.authToken = null;
  }
  
  // åˆ·æ–°token
  private async refreshToken(): Promise<void> {
    try {
      const refreshToken = localStorage.getItem('refreshToken');
      if (!refreshToken) {
        throw new Error('No refresh token available');
      }
      
      const response = await axios.post(`${this.baseURL}/auth/refresh`, {
        refreshToken,
      });
      
      const { accessToken } = response.data.data;
      this.setAuthToken(accessToken);
      localStorage.setItem('accessToken', accessToken);
    } catch (error) {
      // åˆ·æ–°å¤±è´¥ï¼Œè·³è½¬åˆ°ç™»å½•é¡µ
      this.clearAuthToken();
      localStorage.removeItem('accessToken');
      localStorage.removeItem('refreshToken');
      window.location.href = '/auth/login';
    }
  }
  
  // é€šç”¨GETæ–¹æ³•
  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.get<ApiResponse<T>>(url, config);
    return response.data.data;
  }
  
  // é€šç”¨POSTæ–¹æ³•
  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.post<ApiResponse<T>>(url, data, config);
    return response.data.data;
  }
  
  // é€šç”¨PUTæ–¹æ³•
  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.put<ApiResponse<T>>(url, data, config);
    return response.data.data;
  }
  
  // é€šç”¨DELETEæ–¹æ³•
  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.delete<ApiResponse<T>>(url, config);
    return response.data.data;
  }
  
  // æ–‡ä»¶ä¸Šä¼ 
  async upload<T>(url: string, file: File, onProgress?: (progress: number) => void): Promise<T> {
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await this.client.post<ApiResponse<T>>(url, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          onProgress(progress);
        }
      },
    });
    
    return response.data.data;
  }
  
  // é”™è¯¯å¤„ç†
  private handleApiError(error: any): ApiError {
    if (error.response?.data) {
      return error.response.data;
    }
    
    return {
      code: 'NETWORK_ERROR',
      message: error.message || 'Network request failed',
      timestamp: new Date().toISOString(),
      requestId: this.generateRequestId(),
    };
  }
  
  // ç”Ÿæˆè¯·æ±‚ID
  private generateRequestId(): string {
    return `req_${Date.now()}_${Math.random().toString(36).substring(7)}`;
  }
}

// åˆ›å»ºå…¨å±€APIå®¢æˆ·ç«¯å®ä¾‹
export const apiClient = new ApiClient(process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api');
```

### 2. ä¸šåŠ¡APIæœåŠ¡
```typescript
// src/services/products.ts
import { apiClient } from '@/lib/api-client';
import { Product, PaginatedResponse } from '@/types/entities';

export interface ProductFilters {
  type?: string[];
  category?: string[];
  industry?: string[];
  priceMin?: number;
  priceMax?: number;
  rating?: number;
  tags?: string[];
  verified?: boolean;
  search?: string;
}

export interface ProductsParams extends ProductFilters {
  page?: number;
  pageSize?: number;
  sort?: 'name' | 'rating' | 'price' | 'popularity' | 'newest';
  order?: 'asc' | 'desc';
}

class ProductService {
  // è·å–äº§å“åˆ—è¡¨
  async getProducts(params: ProductsParams = {}): Promise<PaginatedResponse<Product>> {
    return apiClient.get('/products', { params });
  }
  
  // è·å–äº§å“è¯¦æƒ…
  async getProduct(id: string): Promise<Product> {
    return apiClient.get(`/products/${id}`);
  }
  
  // æœç´¢äº§å“
  async searchProducts(query: string, filters: ProductFilters = {}): Promise<PaginatedResponse<Product>> {
    return apiClient.post('/products/search', {
      query,
      filters,
    });
  }
  
  // è·å–ç›¸å…³äº§å“æ¨è
  async getRelatedProducts(productId: string): Promise<Product[]> {
    return apiClient.get(`/products/${productId}/related`);
  }
  
  // è·å–çƒ­é—¨äº§å“
  async getPopularProducts(industry?: string): Promise<Product[]> {
    return apiClient.get('/products/popular', {
      params: { industry },
    });
  }
  
  // æ·»åŠ åˆ°æ”¶è—
  async addToFavorites(productId: string): Promise<void> {
    return apiClient.post(`/products/${productId}/favorite`);
  }
  
  // ä»æ”¶è—ä¸­ç§»é™¤
  async removeFromFavorites(productId: string): Promise<void> {
    return apiClient.delete(`/products/${productId}/favorite`);
  }
  
  // è·å–ç”¨æˆ·æ”¶è—çš„äº§å“
  async getFavoriteProducts(): Promise<PaginatedResponse<Product>> {
    return apiClient.get('/user/favorites');
  }
  
  // æäº¤äº§å“è¯„ä»·
  async submitReview(productId: string, review: {
    rating: number;
    title: string;
    content: string;
    pros?: string[];
    cons?: string[];
  }): Promise<void> {
    return apiClient.post(`/products/${productId}/reviews`, review);
  }
  
  // è·å–äº§å“è¯„ä»·
  async getReviews(productId: string, page = 1): Promise<PaginatedResponse<any>> {
    return apiClient.get(`/products/${productId}/reviews`, {
      params: { page },
    });
  }
}

export const productService = new ProductService();
```

### 3. 6è§’è‰²åˆ†ææœåŠ¡
```typescript
// src/services/analysis.ts
import { apiClient } from '@/lib/api-client';
import { AnalysisSession, ProductRecommendation } from '@/types/entities';

export interface AnalysisRequest {
  content: string;
  attachments?: File[];
  context?: {
    industry?: string;
    company?: string;
    budget?: number;
    timeline?: string;
    requirements?: string[];
  };
}

export interface AnalysisStreamEvent {
  type: 'agent_start' | 'agent_progress' | 'agent_complete' | 'synthesis_start' | 'synthesis_complete' | 'error';
  agent?: string;
  progress?: number;
  data?: any;
  error?: string;
}

class AnalysisService {
  // å¯åŠ¨6è§’è‰²åˆ†æ
  async startAnalysis(request: AnalysisRequest): Promise<AnalysisSession> {
    const formData = new FormData();
    formData.append('content', request.content);
    
    if (request.context) {
      formData.append('context', JSON.stringify(request.context));
    }
    
    if (request.attachments) {
      request.attachments.forEach((file, index) => {
        formData.append(`attachment_${index}`, file);
      });
    }
    
    return apiClient.post('/analysis/start', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
  }
  
  // è·å–åˆ†æä¼šè¯è¯¦æƒ…
  async getAnalysisSession(sessionId: string): Promise<AnalysisSession> {
    return apiClient.get(`/analysis/${sessionId}`);
  }
  
  // è·å–ç”¨æˆ·çš„åˆ†æå†å²
  async getAnalysisHistory(): Promise<PaginatedResponse<AnalysisSession>> {
    return apiClient.get('/analysis/history');
  }
  
  // è·å–åŸºäºåˆ†æçš„äº§å“æ¨è
  async getRecommendations(sessionId: string): Promise<ProductRecommendation[]> {
    return apiClient.get(`/analysis/${sessionId}/recommendations`);
  }
  
  // æ·»åŠ åç»­é—®é¢˜åˆ°åˆ†æä¼šè¯
  async addFollowUpQuestion(sessionId: string, question: string): Promise<AnalysisSession> {
    return apiClient.post(`/analysis/${sessionId}/followup`, {
      question,
    });
  }
  
  // å¯¼å‡ºåˆ†ææŠ¥å‘Š
  async exportReport(sessionId: string, format: 'pdf' | 'docx'): Promise<Blob> {
    const response = await apiClient.client.get(`/analysis/${sessionId}/export`, {
      params: { format },
      responseType: 'blob',
    });
    
    return response.data;
  }
  
  // åˆ†äº«åˆ†æä¼šè¯
  async shareSession(sessionId: string, settings: {
    public: boolean;
    expireAt?: Date;
    password?: string;
  }): Promise<{ shareUrl: string }> {
    return apiClient.post(`/analysis/${sessionId}/share`, settings);
  }
  
  // è®¢é˜…åˆ†æè¿›åº¦ (WebSocket)
  subscribeToProgress(sessionId: string, onEvent: (event: AnalysisStreamEvent) => void): () => void {
    const ws = new WebSocket(`${process.env.NEXT_PUBLIC_WS_URL}/analysis/${sessionId}/stream`);
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      onEvent(data);
    };
    
    ws.onerror = (error) => {
      onEvent({
        type: 'error',
        error: 'WebSocketè¿æ¥å¤±è´¥',
      });
    };
    
    // è¿”å›å–æ¶ˆè®¢é˜…å‡½æ•°
    return () => {
      ws.close();
    };
  }
}

export const analysisService = new AnalysisService();
```

---

## ğŸ—„ï¸ çŠ¶æ€ç®¡ç†è®¾è®¡

### 1. å…¨å±€çŠ¶æ€ (Zustand)
```typescript
// src/stores/auth.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { User } from '@/types/entities';
import { authService } from '@/services/auth';

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  
  // Actions
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  updateProfile: (updates: Partial<User>) => Promise<void>;
  refreshUser: () => Promise<void>;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      isAuthenticated: false,
      isLoading: false,
      
      login: async (email: string, password: string) => {
        set({ isLoading: true });
        
        try {
          const { user, tokens } = await authService.login(email, password);
          
          // ä¿å­˜tokens
          localStorage.setItem('accessToken', tokens.accessToken);
          localStorage.setItem('refreshToken', tokens.refreshToken);
          
          // è®¾ç½®API client token
          apiClient.setAuthToken(tokens.accessToken);
          
          set({
            user,
            isAuthenticated: true,
            isLoading: false,
          });
        } catch (error) {
          set({ isLoading: false });
          throw error;
        }
      },
      
      logout: () => {
        // æ¸…é™¤æœ¬åœ°å­˜å‚¨
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        
        // æ¸…é™¤API client token
        apiClient.clearAuthToken();
        
        set({
          user: null,
          isAuthenticated: false,
        });
      },
      
      updateProfile: async (updates: Partial<User>) => {
        const updatedUser = await authService.updateProfile(updates);
        
        set({
          user: updatedUser,
        });
      },
      
      refreshUser: async () => {
        try {
          const user = await authService.getCurrentUser();
          set({ user, isAuthenticated: true });
        } catch (error) {
          // ç”¨æˆ·ä¿¡æ¯è·å–å¤±è´¥ï¼Œå¯èƒ½tokenè¿‡æœŸ
          get().logout();
        }
      },
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);
```

### 2. åˆ†æä¼šè¯çŠ¶æ€
```typescript
// src/stores/analysis.ts
import { create } from 'zustand';
import { subscribeWithSelector } from 'zustand/middleware';
import { AnalysisSession, ChatMessage, AgentRole } from '@/types/entities';
import { analysisService } from '@/services/analysis';

interface AnalysisState {
  currentSession: AnalysisSession | null;
  sessions: AnalysisSession[];
  isAnalyzing: boolean;
  activeAgents: AgentRole[];
  
  // Actions
  startAnalysis: (content: string, attachments?: File[]) => Promise<void>;
  addFollowUp: (question: string) => Promise<void>;
  loadSession: (sessionId: string) => Promise<void>;
  loadHistory: () => Promise<void>;
  clearCurrentSession: () => void;
  
  // Real-time updates
  updateAgentProgress: (agent: AgentRole, progress: number) => void;
  completeAgentAnalysis: (agent: AgentRole, result: any) => void;
}

export const useAnalysisStore = create<AnalysisState>()(
  subscribeWithSelector((set, get) => ({
    currentSession: null,
    sessions: [],
    isAnalyzing: false,
    activeAgents: [],
    
    startAnalysis: async (content: string, attachments?: File[]) => {
      set({ isAnalyzing: true, activeAgents: [] });
      
      try {
        const session = await analysisService.startAnalysis({
          content,
          attachments,
        });
        
        set({
          currentSession: session,
          isAnalyzing: true,
          activeAgents: ['alex'], // é¦–å…ˆæ¿€æ´»Alex
        });
        
        // è®¢é˜…å®æ—¶è¿›åº¦æ›´æ–°
        const unsubscribe = analysisService.subscribeToProgress(
          session.id,
          (event) => {
            const store = get();
            
            switch (event.type) {
              case 'agent_start':
                if (event.agent) {
                  store.updateAgentProgress(event.agent as AgentRole, 0);
                }
                break;
                
              case 'agent_progress':
                if (event.agent && typeof event.progress === 'number') {
                  store.updateAgentProgress(event.agent as AgentRole, event.progress);
                }
                break;
                
              case 'agent_complete':
                if (event.agent) {
                  store.completeAgentAnalysis(event.agent as AgentRole, event.data);
                }
                break;
                
              case 'synthesis_complete':
                set({
                  isAnalyzing: false,
                  activeAgents: [],
                  currentSession: {
                    ...store.currentSession!,
                    ...event.data,
                  },
                });
                unsubscribe();
                break;
                
              case 'error':
                set({ isAnalyzing: false, activeAgents: [] });
                unsubscribe();
                break;
            }
          }
        );
        
      } catch (error) {
        set({ isAnalyzing: false, activeAgents: [] });
        throw error;
      }
    },
    
    addFollowUp: async (question: string) => {
      const { currentSession } = get();
      if (!currentSession) return;
      
      const updatedSession = await analysisService.addFollowUpQuestion(
        currentSession.id,
        question
      );
      
      set({ currentSession: updatedSession });
    },
    
    loadSession: async (sessionId: string) => {
      const session = await analysisService.getAnalysisSession(sessionId);
      set({ currentSession: session });
    },
    
    loadHistory: async () => {
      const { items } = await analysisService.getAnalysisHistory();
      set({ sessions: items });
    },
    
    clearCurrentSession: () => {
      set({ currentSession: null, isAnalyzing: false, activeAgents: [] });
    },
    
    updateAgentProgress: (agent: AgentRole, progress: number) => {
      const { currentSession, activeAgents } = get();
      if (!currentSession) return;
      
      // å¦‚æœagentä¸åœ¨æ´»è·ƒåˆ—è¡¨ä¸­ï¼Œæ·»åŠ å®ƒ
      if (!activeAgents.includes(agent)) {
        set({ activeAgents: [...activeAgents, agent] });
      }
      
      set({
        currentSession: {
          ...currentSession,
          analysis: {
            ...currentSession.analysis,
            [agent]: {
              ...currentSession.analysis[agent],
              status: 'analyzing',
              // å¯ä»¥æ·»åŠ è¿›åº¦å­—æ®µ
            },
          },
        },
      });
    },
    
    completeAgentAnalysis: (agent: AgentRole, result: any) => {
      const { currentSession, activeAgents } = get();
      if (!currentSession) return;
      
      set({
        currentSession: {
          ...currentSession,
          analysis: {
            ...currentSession.analysis,
            [agent]: {
              ...result,
              status: 'completed',
            },
          },
        },
        activeAgents: activeAgents.filter(a => a !== agent),
      });
    },
  }))
);
```

### 3. æœåŠ¡å™¨çŠ¶æ€ç®¡ç† (TanStack Query)
```typescript
// src/hooks/use-products.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { productService } from '@/services/products';
import { ProductsParams, ProductFilters } from '@/services/products';

// äº§å“åˆ—è¡¨æŸ¥è¯¢
export const useProducts = (params: ProductsParams) => {
  return useQuery({
    queryKey: ['products', params],
    queryFn: () => productService.getProducts(params),
    staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿ
    cacheTime: 30 * 60 * 1000, // 30åˆ†é’Ÿ
    keepPreviousData: true,
  });
};

// äº§å“è¯¦æƒ…æŸ¥è¯¢
export const useProduct = (productId: string) => {
  return useQuery({
    queryKey: ['product', productId],
    queryFn: () => productService.getProduct(productId),
    enabled: !!productId,
    staleTime: 10 * 60 * 1000, // 10åˆ†é’Ÿ
    cacheTime: 60 * 60 * 1000, // 1å°æ—¶
  });
};

// äº§å“æœç´¢
export const useProductSearch = () => {
  return useMutation({
    mutationFn: ({ query, filters }: { query: string; filters?: ProductFilters }) =>
      productService.searchProducts(query, filters),
  });
};

// æ”¶è—äº§å“
export const useFavoriteProduct = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (productId: string) => productService.addToFavorites(productId),
    onSuccess: (_, productId) => {
      // æ›´æ–°äº§å“è¯¦æƒ…ç¼“å­˜
      queryClient.invalidateQueries(['product', productId]);
      // æ›´æ–°æ”¶è—åˆ—è¡¨ç¼“å­˜
      queryClient.invalidateQueries(['user', 'favorites']);
    },
  });
};

// å–æ¶ˆæ”¶è—
export const useUnfavoriteProduct = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (productId: string) => productService.removeFromFavorites(productId),
    onSuccess: (_, productId) => {
      queryClient.invalidateQueries(['product', productId]);
      queryClient.invalidateQueries(['user', 'favorites']);
    },
  });
};

// é¢„åŠ è½½ç›¸å…³äº§å“
export const usePrefetchRelatedProducts = () => {
  const queryClient = useQueryClient();
  
  return (productId: string) => {
    queryClient.prefetchQuery({
      queryKey: ['products', 'related', productId],
      queryFn: () => productService.getRelatedProducts(productId),
      staleTime: 10 * 60 * 1000,
    });
  };
};
```

---

## âš¡ å®æ—¶æ•°æ®åŒæ­¥

### 1. WebSocketç®¡ç†å™¨
```typescript
// src/lib/websocket.ts
import { WebSocketMessage } from '@/types/api';

interface WebSocketOptions {
  reconnectAttempts?: number;
  reconnectInterval?: number;
  heartbeatInterval?: number;
}

class WebSocketManager {
  private ws: WebSocket | null = null;
  private url: string;
  private options: Required<WebSocketOptions>;
  private reconnectCount = 0;
  private heartbeatTimer: NodeJS.Timeout | null = null;
  private eventHandlers: Map<string, Set<(data: any) => void>> = new Map();
  
  constructor(url: string, options: WebSocketOptions = {}) {
    this.url = url;
    this.options = {
      reconnectAttempts: 5,
      reconnectInterval: 5000,
      heartbeatInterval: 30000,
      ...options,
    };
  }
  
  connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        this.ws = new WebSocket(this.url);
        
        this.ws.onopen = () => {
          console.log('WebSocket connected');
          this.reconnectCount = 0;
          this.startHeartbeat();
          resolve();
        };
        
        this.ws.onmessage = (event) => {
          try {
            const message: WebSocketMessage = JSON.parse(event.data);
            this.handleMessage(message);
          } catch (error) {
            console.error('Failed to parse WebSocket message:', error);
          }
        };
        
        this.ws.onclose = (event) => {
          console.log('WebSocket disconnected:', event.code, event.reason);
          this.stopHeartbeat();
          
          if (event.code !== 1000 && this.reconnectCount < this.options.reconnectAttempts) {
            setTimeout(() => this.reconnect(), this.options.reconnectInterval);
          }
        };
        
        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          reject(error);
        };
        
      } catch (error) {
        reject(error);
      }
    });
  }
  
  disconnect(): void {
    if (this.ws) {
      this.ws.close(1000, 'Client disconnect');
      this.ws = null;
    }
    this.stopHeartbeat();
  }
  
  private async reconnect(): Promise<void> {
    this.reconnectCount++;
    console.log(`Attempting to reconnect (${this.reconnectCount}/${this.options.reconnectAttempts})`);
    
    try {
      await this.connect();
    } catch (error) {
      if (this.reconnectCount >= this.options.reconnectAttempts) {
        console.error('Max reconnection attempts reached');
        this.emit('connection_failed', { error });
      }
    }
  }
  
  private startHeartbeat(): void {
    this.heartbeatTimer = setInterval(() => {
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.send('ping', {});
      }
    }, this.options.heartbeatInterval);
  }
  
  private stopHeartbeat(): void {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  
  private handleMessage(message: WebSocketMessage): void {
    // å¤„ç†å¿ƒè·³å“åº”
    if (message.type === 'pong') {
      return;
    }
    
    // åˆ†å‘æ¶ˆæ¯ç»™å¯¹åº”çš„å¤„ç†å™¨
    this.emit(message.type, message.payload);
  }
  
  send(type: string, payload: any): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      const message: WebSocketMessage = {
        type,
        payload,
        timestamp: new Date().toISOString(),
      };
      
      this.ws.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket is not connected, message not sent:', type);
    }
  }
  
  on(eventType: string, handler: (data: any) => void): () => void {
    if (!this.eventHandlers.has(eventType)) {
      this.eventHandlers.set(eventType, new Set());
    }
    
    this.eventHandlers.get(eventType)!.add(handler);
    
    // è¿”å›å–æ¶ˆç›‘å¬å‡½æ•°
    return () => {
      this.eventHandlers.get(eventType)?.delete(handler);
    };
  }
  
  private emit(eventType: string, data: any): void {
    const handlers = this.eventHandlers.get(eventType);
    if (handlers) {
      handlers.forEach((handler) => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Error in WebSocket event handler for ${eventType}:`, error);
        }
      });
    }
  }
  
  isConnected(): boolean {
    return this.ws?.readyState === WebSocket.OPEN;
  }
}

// åˆ›å»ºå…¨å±€WebSocketå®ä¾‹
export const wsManager = new WebSocketManager(
  process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:3000/ws'
);
```

### 2. å®æ—¶æ•°æ®Hook
```typescript
// src/hooks/use-realtime.ts
import { useEffect, useRef } from 'react';
import { wsManager } from '@/lib/websocket';

export const useRealtimeAnalysis = (
  sessionId: string,
  onProgress: (event: any) => void
) => {
  const handlerRef = useRef(onProgress);
  
  // æ›´æ–°å¤„ç†å™¨å¼•ç”¨
  useEffect(() => {
    handlerRef.current = onProgress;
  }, [onProgress]);
  
  useEffect(() => {
    if (!sessionId) return;
    
    // è®¢é˜…åˆ†æè¿›åº¦äº‹ä»¶
    const unsubscribe = wsManager.on(`analysis_progress_${sessionId}`, (data) => {
      handlerRef.current(data);
    });
    
    // å‘é€è®¢é˜…è¯·æ±‚
    wsManager.send('subscribe_analysis', { sessionId });
    
    return () => {
      // å–æ¶ˆè®¢é˜…
      wsManager.send('unsubscribe_analysis', { sessionId });
      unsubscribe();
    };
  }, [sessionId]);
};

export const useRealtimeNotifications = (
  userId: string,
  onNotification: (notification: any) => void
) => {
  const handlerRef = useRef(onNotification);
  
  useEffect(() => {
    handlerRef.current = onNotification;
  }, [onNotification]);
  
  useEffect(() => {
    if (!userId) return;
    
    const unsubscribe = wsManager.on(`user_notification_${userId}`, (data) => {
      handlerRef.current(data);
    });
    
    wsManager.send('subscribe_notifications', { userId });
    
    return () => {
      wsManager.send('unsubscribe_notifications', { userId });
      unsubscribe();
    };
  }, [userId]);
};
```

---

## ğŸ’¾ æ™ºèƒ½ç¼“å­˜ç­–ç•¥

### 1. ç¼“å­˜é…ç½®
```typescript
// src/lib/cache-config.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // é»˜è®¤ç¼“å­˜æ—¶é—´ï¼š5åˆ†é’Ÿ
      staleTime: 5 * 60 * 1000,
      // å†…å­˜ä¸­ä¿ç•™æ—¶é—´ï¼š30åˆ†é’Ÿ
      cacheTime: 30 * 60 * 1000,
      // é‡è¯•é…ç½®
      retry: (failureCount, error: any) => {
        // 4xxé”™è¯¯ä¸é‡è¯•
        if (error?.response?.status >= 400 && error?.response?.status < 500) {
          return false;
        }
        return failureCount < 3;
      },
      // é‡è¯•å»¶è¿Ÿ
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
    mutations: {
      retry: 1,
    },
  },
});

// é¢„åŠ è½½ç­–ç•¥
export const PREFETCH_STRATEGIES = {
  // äº§å“ç›¸å…³æ•°æ®é¢„åŠ è½½
  products: {
    relatedProducts: 'hover', // æ‚¬æµ®æ—¶é¢„åŠ è½½ç›¸å…³äº§å“
    productDetails: 'click', // ç‚¹å‡»æ—¶é¢„åŠ è½½è¯¦æƒ…
    vendorInfo: 'visible', // å¯è§æ—¶é¢„åŠ è½½ä¾›åº”å•†ä¿¡æ¯
  },
  
  // ç”¨æˆ·æ•°æ®é¢„åŠ è½½
  user: {
    preferences: 'login', // ç™»å½•æ—¶é¢„åŠ è½½åå¥½è®¾ç½®
    history: 'dashboard', // è¿›å…¥ä»ªè¡¨æ¿æ—¶é¢„åŠ è½½å†å²
    favorites: 'market', // è¿›å…¥å¸‚åœºæ—¶é¢„åŠ è½½æ”¶è—
  },
  
  // AIåˆ†ææ•°æ®é¢„åŠ è½½
  analysis: {
    templates: 'chat', // è¿›å…¥èŠå¤©æ—¶é¢„åŠ è½½æ¨¡æ¿
    history: 'dashboard', // ä»ªè¡¨æ¿é¢„åŠ è½½å†å²åˆ†æ
    recommendations: 'complete', // åˆ†æå®Œæˆæ—¶é¢„åŠ è½½æ¨è
  },
} as const;
```

### 2. é¢„æµ‹æ€§ç¼“å­˜
```typescript
// src/hooks/use-predictive-cache.ts
import { useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { productService } from '@/services/products';

export const usePredictiveProductCache = () => {
  const queryClient = useQueryClient();
  
  // åŸºäºç”¨æˆ·è¡Œä¸ºé¢„åŠ è½½äº§å“æ•°æ®
  const prefetchProduct = (productId: string, priority: 'low' | 'high' = 'low') => {
    const prefetchOptions = {
      staleTime: 10 * 60 * 1000, // 10åˆ†é’Ÿ
      cacheTime: 60 * 60 * 1000, // 1å°æ—¶
    };
    
    // é¢„åŠ è½½äº§å“è¯¦æƒ…
    queryClient.prefetchQuery({
      queryKey: ['product', productId],
      queryFn: () => productService.getProduct(productId),
      ...prefetchOptions,
    });
    
    if (priority === 'high') {
      // é«˜ä¼˜å…ˆçº§æ—¶ï¼ŒåŒæ—¶é¢„åŠ è½½ç›¸å…³äº§å“
      queryClient.prefetchQuery({
        queryKey: ['products', 'related', productId],
        queryFn: () => productService.getRelatedProducts(productId),
        ...prefetchOptions,
      });
    }
  };
  
  // åŸºäºæµè§ˆå†å²é¢„æµ‹ç”¨æˆ·å…´è¶£
  const prefetchByUserInterest = (viewedProducts: string[]) => {
    // åˆ†æç”¨æˆ·æµè§ˆçš„äº§å“ç±»å‹
    const productTypes = new Set();
    const industries = new Set();
    
    viewedProducts.forEach(productId => {
      // ä»ç¼“å­˜ä¸­è·å–äº§å“ä¿¡æ¯è¿›è¡Œåˆ†æ
      const cachedProduct = queryClient.getQueryData(['product', productId]);
      if (cachedProduct) {
        productTypes.add((cachedProduct as any).type);
        (cachedProduct as any).industry.forEach((ind: string) => industries.add(ind));
      }
    });
    
    // é¢„åŠ è½½ç›¸ä¼¼ç±»å‹çš„çƒ­é—¨äº§å“
    Array.from(industries).forEach(industry => {
      queryClient.prefetchQuery({
        queryKey: ['products', 'popular', industry],
        queryFn: () => productService.getPopularProducts(industry as string),
        staleTime: 15 * 60 * 1000,
      });
    });
  };
  
  return {
    prefetchProduct,
    prefetchByUserInterest,
  };
};

// æ™ºèƒ½ç¼“å­˜æ¸…ç†
export const useCacheOptimization = () => {
  const queryClient = useQueryClient();
  
  useEffect(() => {
    // ç›‘å¬å†…å­˜ä½¿ç”¨æƒ…å†µ
    const checkMemoryUsage = () => {
      if ('memory' in performance) {
        const memInfo = (performance as any).memory;
        const usageRatio = memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit;
        
        // å¦‚æœå†…å­˜ä½¿ç”¨ç‡è¶…è¿‡80%ï¼Œä¸»åŠ¨æ¸…ç†ç¼“å­˜
        if (usageRatio > 0.8) {
          queryClient.clear();
          console.log('Cache cleared due to high memory usage');
        }
      }
    };
    
    const interval = setInterval(checkMemoryUsage, 30000); // 30ç§’æ£€æŸ¥ä¸€æ¬¡
    
    return () => clearInterval(interval);
  }, [queryClient]);
  
  // æ™ºèƒ½ç¼“å­˜å¤±æ•ˆ
  const invalidateByUserAction = (action: string, context: any) => {
    switch (action) {
      case 'favorite_product':
        // æ”¶è—äº§å“åï¼Œå¤±æ•ˆç›¸å…³ç¼“å­˜
        queryClient.invalidateQueries(['user', 'favorites']);
        queryClient.invalidateQueries(['product', context.productId]);
        break;
        
      case 'complete_analysis':
        // å®Œæˆåˆ†æåï¼Œé¢„åŠ è½½æ¨èäº§å“
        if (context.recommendations) {
          context.recommendations.forEach((rec: any) => {
            queryClient.prefetchQuery({
              queryKey: ['product', rec.product.id],
              queryFn: () => productService.getProduct(rec.product.id),
            });
          });
        }
        break;
        
      case 'view_product':
        // æŸ¥çœ‹äº§å“åï¼Œé¢„æµ‹æ€§åŠ è½½ç›¸å…³å†…å®¹
        queryClient.prefetchQuery({
          queryKey: ['products', 'related', context.productId],
          queryFn: () => productService.getRelatedProducts(context.productId),
        });
        break;
    }
  };
  
  return {
    invalidateByUserAction,
  };
};
```

---

## ğŸ“‹ æ•°æ®äº¤äº’å®ç°æ¸…å•

### APIå®¢æˆ·ç«¯å®ç°
- [ ] åŸºç¡€HTTPå®¢æˆ·ç«¯å’Œæ‹¦æˆªå™¨
- [ ] è®¤è¯tokenç®¡ç†å’Œåˆ·æ–°æœºåˆ¶
- [ ] é”™è¯¯å¤„ç†å’Œé‡è¯•ç­–ç•¥
- [ ] æ–‡ä»¶ä¸Šä¼ å’Œè¿›åº¦è·Ÿè¸ª
- [ ] è¯·æ±‚ç¼“å­˜å’Œå»é‡æœºåˆ¶

### ä¸šåŠ¡æœåŠ¡å®ç°
- [ ] äº§å“æœåŠ¡ï¼šCRUDæ“ä½œå’Œæœç´¢
- [ ] ç”¨æˆ·æœåŠ¡ï¼šè®¤è¯å’Œä¸ªäººèµ„æ–™ç®¡ç†
- [ ] åˆ†ææœåŠ¡ï¼š6è§’è‰²AIåä½œæ¥å£
- [ ] è®¢å•æœåŠ¡ï¼šè´­ä¹°æµç¨‹å’Œæ”¯ä»˜é›†æˆ
- [ ] é€šçŸ¥æœåŠ¡ï¼šå®æ—¶æ¶ˆæ¯æ¨é€

### çŠ¶æ€ç®¡ç†å®ç°
- [ ] å…¨å±€çŠ¶æ€ï¼šç”¨æˆ·è®¤è¯å’Œåº”ç”¨è®¾ç½®
- [ ] ä¸šåŠ¡çŠ¶æ€ï¼šåˆ†æä¼šè¯å’Œäº§å“æ•°æ®
- [ ] è¡¨å•çŠ¶æ€ï¼šå¤æ‚è¡¨å•çš„çŠ¶æ€ç®¡ç†
- [ ] ç¼“å­˜çŠ¶æ€ï¼šæ™ºèƒ½ç¼“å­˜ç­–ç•¥å®ç°
- [ ] æŒä¹…åŒ–çŠ¶æ€ï¼šæœ¬åœ°å­˜å‚¨åŒæ­¥

### å®æ—¶é€šä¿¡å®ç°
- [ ] WebSocketè¿æ¥ç®¡ç†
- [ ] æ–­çº¿é‡è¿å’Œé”™è¯¯æ¢å¤
- [ ] æ¶ˆæ¯åˆ†å‘å’Œäº‹ä»¶å¤„ç†
- [ ] å¿ƒè·³æ£€æµ‹å’Œè¿æ¥çŠ¶æ€
- [ ] é¢‘é“è®¢é˜…å’Œå–æ¶ˆæœºåˆ¶

### æ€§èƒ½ä¼˜åŒ–å®ç°
- [ ] é¢„æµ‹æ€§æ•°æ®é¢„åŠ è½½
- [ ] æ™ºèƒ½ç¼“å­˜å¤±æ•ˆç­–ç•¥
- [ ] å†…å­˜ä½¿ç”¨ç›‘æ§å’Œæ¸…ç†
- [ ] ç½‘ç»œè¯·æ±‚ä¼˜åŒ–
- [ ] æ‰¹é‡æ“ä½œå’Œé˜²æŠ–å¤„ç†

### é”™è¯¯å¤„ç†å®ç°
- [ ] å…¨å±€é”™è¯¯è¾¹ç•Œå’Œå¤„ç†
- [ ] ç½‘ç»œé”™è¯¯æ¢å¤æœºåˆ¶
- [ ] ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º
- [ ] é”™è¯¯æ—¥å¿—å’Œç›‘æ§é›†æˆ
- [ ] é™çº§ç­–ç•¥å’Œå›é€€æ–¹æ¡ˆ

---

**æ€»ç»“**: zhilink-v3çš„æ•°æ®äº¤äº’è®¾è®¡åŸºäºç°ä»£åŒ–çš„æŠ€æœ¯æ ˆå’Œæœ€ä½³å®è·µï¼Œé€šè¿‡ç±»å‹å®‰å…¨çš„APIå®¢æˆ·ç«¯ã€æ™ºèƒ½çš„çŠ¶æ€ç®¡ç†ã€å®æ—¶çš„æ•°æ®åŒæ­¥å’Œé¢„æµ‹æ€§çš„ç¼“å­˜ç­–ç•¥ï¼Œä¸º6è§’è‰²AIåä½œç³»ç»Ÿæä¾›äº†åšå®çš„æ•°æ®åŸºç¡€ã€‚è¿™å¥—æ¶æ„ä¸ä»…èƒ½å¤Ÿæ”¯æŒå½“å‰çš„ä¸šåŠ¡éœ€æ±‚ï¼Œè¿˜ä¸ºæœªæ¥çš„åŠŸèƒ½æ‰©å±•é¢„ç•™äº†å……åˆ†çš„ç©ºé—´ã€‚

é€šè¿‡å®Œæ•´çš„6ä¸ªè®¾è®¡æ–‡æ¡£ï¼Œzhilink-v3é¡¹ç›®ç°åœ¨æ‹¥æœ‰äº†ä»æŠ€æœ¯æ¶æ„åˆ°æ•°æ®äº¤äº’çš„å…¨æ–¹ä½æŒ‡å¯¼ï¼Œå¯ä»¥æ”¯æŒå¼€å‘å›¢é˜Ÿè¿›è¡Œé«˜æ•ˆã€è§„èŒƒçš„å¼€å‘å·¥ä½œï¼Œç¡®ä¿æœ€ç»ˆäº§å“èƒ½å¤Ÿå®ç°é¢„æœŸçš„ç”¨æˆ·ä½“éªŒå’Œä¸šåŠ¡ç›®æ ‡ã€‚