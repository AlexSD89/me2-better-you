# 第4轮细节优化：智链平台v2技术架构与开发实施

**版本**: v2.0 | **日期**: 2025-08-12 | **状态**: 第4轮细节优化  
**目标**: 基于2025年最佳实践构建可扩展、高可用、安全的微服务架构系统

---

## 🏗️ 微服务架构设计

### 核心微服务拆分策略
```yaml
微服务架构总览:
  
  # 用户域服务
  user-service:
    职责: 用户认证、授权、画像管理
    技术栈: Node.js + TypeScript + JWT + Redis
    数据存储: PostgreSQL (用户信息) + Redis (会话缓存)
    端口: 3001
    容器资源: CPU 0.5核, 内存 512MB
  
  # 推荐引擎服务  
  recommendation-service:
    职责: AI推荐算法、六角色协作引擎
    技术栈: Python + FastAPI + TensorFlow + Celery
    数据存储: PostgreSQL + Elasticsearch + Redis
    端口: 3002
    容器资源: CPU 2核, 内存 4GB
    
  # 供应商管理服务
  supplier-service:
    职责: 供应商注册、能力管理、质量评估
    技术栈: Node.js + TypeScript + Prisma
    数据存储: PostgreSQL + MongoDB (非结构化数据)
    端口: 3003
    容器资源: CPU 1核, 内存 1GB
    
  # 交易管理服务
  transaction-service:
    职责: 订单处理、支付管理、结算
    技术栈: Node.js + TypeScript + Stripe SDK
    数据存储: PostgreSQL + Redis
    端口: 3004  
    容器资源: CPU 1核, 内存 1GB
    
  # 通知服务
  notification-service:
    职责: 邮件、短信、站内消息推送
    技术栈: Node.js + TypeScript + RabbitMQ
    数据存储: PostgreSQL + Redis
    端口: 3005
    容器资源: CPU 0.5核, 内存 512MB
    
  # 数据分析服务
  analytics-service:
    职责: 业务数据分析、报表生成、监控指标
    技术栈: Python + FastAPI + Pandas + ClickHouse
    数据存储: ClickHouse (时序数据) + PostgreSQL
    端口: 3006
    容器资源: CPU 1核, 内存 2GB
    
  # API网关
  api-gateway:
    职责: 路由、认证、限流、负载均衡
    技术栈: Kong + Lua + Redis
    端口: 3000
    容器资源: CPU 1核, 内存 512MB
```

### Docker化部署配置
```dockerfile
# 推荐服务 Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# 复制依赖文件
COPY package*.json ./
COPY tsconfig.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY src/ ./src/

# 构建应用
RUN npm run build

# 生产环境镜像
FROM node:18-alpine AS production

WORKDIR /app

# 创建非root用户
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodeuser -u 1001

# 复制构建产物
COPY --from=builder --chown=nodeuser:nodejs /app/dist ./dist
COPY --from=builder --chown=nodeuser:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodeuser:nodejs /app/package*.json ./

# 设置用户
USER nodeuser

# 暴露端口
EXPOSE 3002

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3002/health || exit 1

# 启动命令
CMD ["node", "dist/index.js"]
```

### Kubernetes部署配置
```yaml
# recommendation-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: recommendation-service
  labels:
    app: recommendation-service
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: recommendation-service
  template:
    metadata:
      labels:
        app: recommendation-service
        version: v1
    spec:
      containers:
      - name: recommendation-service
        image: zhilink/recommendation-service:latest
        ports:
        - containerPort: 3002
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secrets
              key: recommendation-db-url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secrets
              key: redis-url
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3002
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3002
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
      volumes:
      - name: config-volume
        configMap:
          name: recommendation-config

---
apiVersion: v1
kind: Service
metadata:
  name: recommendation-service
spec:
  selector:
    app: recommendation-service
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3002
  type: ClusterIP

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: recommendation-service-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: "100"
spec:
  tls:
  - hosts:
    - api.zhilink.com
    secretName: zhilink-tls
  rules:
  - host: api.zhilink.com
    http:
      paths:
      - path: /api/v1/recommendations
        pathType: Prefix
        backend:
          service:
            name: recommendation-service
            port:
              number: 80
```

---

## 💾 数据库设计与优化

### PostgreSQL数据库模式设计
```sql
-- 用户表设计
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    company_name VARCHAR(255) NOT NULL,
    company_size company_size_enum NOT NULL,
    industry industry_enum NOT NULL,
    role user_role_enum DEFAULT 'client',
    profile JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引优化查询性能
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_company_size ON users(company_size);
CREATE INDEX idx_users_industry ON users(industry);
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_users_profile_gin ON users USING gin(profile);

-- 需求表设计
CREATE TABLE requirements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    budget_min INTEGER,
    budget_max INTEGER,
    timeline_days INTEGER,
    complexity_score DECIMAL(3,2) CHECK (complexity_score >= 0 AND complexity_score <= 1),
    industry industry_enum NOT NULL,
    urgency_level urgency_enum DEFAULT 'medium',
    status requirement_status_enum DEFAULT 'draft',
    tags TEXT[] DEFAULT '{}',
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 需求表索引
CREATE INDEX idx_requirements_user_id ON requirements(user_id);
CREATE INDEX idx_requirements_status ON requirements(status);
CREATE INDEX idx_requirements_industry ON requirements(industry);
CREATE INDEX idx_requirements_budget ON requirements(budget_min, budget_max);
CREATE INDEX idx_requirements_timeline ON requirements(timeline_days);
CREATE INDEX idx_requirements_complexity ON requirements(complexity_score);
CREATE INDEX idx_requirements_tags_gin ON requirements USING gin(tags);
CREATE INDEX idx_requirements_created_at ON requirements(created_at DESC);

-- 供应商能力表设计
CREATE TABLE supplier_capabilities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    supplier_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT NOT NULL,
    category capability_category_enum NOT NULL,
    subcategory VARCHAR(100),
    skills TEXT[] NOT NULL DEFAULT '{}',
    pricing_model pricing_model_enum NOT NULL,
    base_price INTEGER,
    unit_price INTEGER,
    commission_rate DECIMAL(5,2),
    min_budget INTEGER,
    max_budget INTEGER,
    estimated_timeline INTEGER,
    success_rate DECIMAL(5,2) DEFAULT 0,
    rating DECIMAL(3,2) DEFAULT 0,
    review_count INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT true,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 供应商能力表索引
CREATE INDEX idx_capabilities_supplier_id ON supplier_capabilities(supplier_id);
CREATE INDEX idx_capabilities_category ON supplier_capabilities(category);
CREATE INDEX idx_capabilities_skills_gin ON supplier_capabilities USING gin(skills);
CREATE INDEX idx_capabilities_pricing ON supplier_capabilities(pricing_model, base_price);
CREATE INDEX idx_capabilities_rating ON supplier_capabilities(rating DESC);
CREATE INDEX idx_capabilities_active ON supplier_capabilities(is_active) WHERE is_active = true;

-- 推荐记录表
CREATE TABLE recommendations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    requirement_id UUID NOT NULL REFERENCES requirements(id) ON DELETE CASCADE,
    capability_id UUID NOT NULL REFERENCES supplier_capabilities(id) ON DELETE CASCADE,
    algorithm_version VARCHAR(50) NOT NULL,
    confidence_score DECIMAL(5,4) NOT NULL,
    ranking INTEGER NOT NULL,
    reasoning JSONB DEFAULT '{}',
    user_action recommendation_action_enum,
    feedback_rating INTEGER CHECK (feedback_rating >= 1 AND feedback_rating <= 5),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 推荐记录表索引
CREATE INDEX idx_recommendations_requirement ON recommendations(requirement_id);
CREATE INDEX idx_recommendations_capability ON recommendations(capability_id);
CREATE INDEX idx_recommendations_confidence ON recommendations(confidence_score DESC);
CREATE INDEX idx_recommendations_ranking ON recommendations(ranking);
CREATE INDEX idx_recommendations_created_at ON recommendations(created_at DESC);

-- 枚举类型定义
CREATE TYPE company_size_enum AS ENUM ('startup', 'small', 'medium', 'large');
CREATE TYPE industry_enum AS ENUM ('manufacturing', 'finance', 'retail', 'healthcare', 'education', 'other');
CREATE TYPE user_role_enum AS ENUM ('client', 'supplier', 'admin');
CREATE TYPE urgency_enum AS ENUM ('low', 'medium', 'high');
CREATE TYPE requirement_status_enum AS ENUM ('draft', 'published', 'in_progress', 'completed', 'cancelled');
CREATE TYPE capability_category_enum AS ENUM ('workforce', 'expert_module', 'market_report');
CREATE TYPE pricing_model_enum AS ENUM ('fixed', 'hourly', 'project', 'commission');
CREATE TYPE recommendation_action_enum AS ENUM ('viewed', 'clicked', 'contacted', 'hired', 'dismissed');
```

### Redis缓存策略设计
```typescript
// Redis缓存管理类
class CacheManager {
  private redis: Redis.Redis;
  
  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST,
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      retryDelayOnFailover: 100,
      db: 0,
    });
  }
  
  // 用户会话缓存
  async setUserSession(userId: string, sessionData: object, ttl: number = 3600): Promise<void> {
    const key = `session:${userId}`;
    await this.redis.setex(key, ttl, JSON.stringify(sessionData));
  }
  
  async getUserSession(userId: string): Promise<object | null> {
    const key = `session:${userId}`;
    const data = await this.redis.get(key);
    return data ? JSON.parse(data) : null;
  }
  
  // 推荐结果缓存
  async cacheRecommendations(requirementId: string, recommendations: any[], ttl: number = 1800): Promise<void> {
    const key = `recommendations:${requirementId}`;
    await this.redis.setex(key, ttl, JSON.stringify(recommendations));
  }
  
  async getCachedRecommendations(requirementId: string): Promise<any[] | null> {
    const key = `recommendations:${requirementId}`;
    const data = await this.redis.get(key);
    return data ? JSON.parse(data) : null;
  }
  
  // 供应商能力缓存
  async cacheSupplierCapabilities(supplierId: string, capabilities: any[], ttl: number = 3600): Promise<void> {
    const key = `supplier:capabilities:${supplierId}`;
    await this.redis.setex(key, ttl, JSON.stringify(capabilities));
  }
  
  // API限流缓存
  async checkRateLimit(identifier: string, limit: number, window: number): Promise<{ allowed: boolean; remaining: number }> {
    const key = `rate_limit:${identifier}`;
    
    const multi = this.redis.multi();
    multi.incr(key);
    multi.expire(key, window);
    
    const results = await multi.exec();
    const current = results?.[0]?.[1] as number || 0;
    
    const allowed = current <= limit;
    const remaining = Math.max(0, limit - current);
    
    return { allowed, remaining };
  }
  
  // 热门搜索缓存
  async cachePopularSearches(searches: string[], ttl: number = 7200): Promise<void> {
    const key = 'popular_searches';
    await this.redis.setex(key, ttl, JSON.stringify(searches));
  }
  
  // 缓存失效策略
  async invalidateUserCache(userId: string): Promise<void> {
    const patterns = [
      `session:${userId}`,
      `user:profile:${userId}`,
      `user:preferences:${userId}`
    ];
    
    for (const pattern of patterns) {
      await this.redis.del(pattern);
    }
  }
}
```

---

## 🔄 消息队列与异步处理

### RabbitMQ消息队列配置
```typescript
// 消息队列管理器
import amqp from 'amqplib';

export class MessageQueueManager {
  private connection: amqp.Connection | null = null;
  private channel: amqp.Channel | null = null;
  
  async connect(): Promise<void> {
    try {
      this.connection = await amqp.connect(process.env.RABBITMQ_URL!);
      this.channel = await this.connection.createChannel();
      
      // 定义交换器
      await this.channel.assertExchange('zhilink.events', 'topic', { durable: true });
      await this.channel.assertExchange('zhilink.dlx', 'topic', { durable: true });
      
      // 定义队列
      await this.setupQueues();
      
      console.log('RabbitMQ连接成功');
    } catch (error) {
      console.error('RabbitMQ连接失败:', error);
      throw error;
    }
  }
  
  private async setupQueues(): Promise<void> {
    const queues = [
      {
        name: 'recommendation.generate',
        routingKey: 'recommendation.generate',
        options: {
          durable: true,
          arguments: {
            'x-dead-letter-exchange': 'zhilink.dlx',
            'x-dead-letter-routing-key': 'recommendation.generate.failed',
            'x-message-ttl': 300000  // 5分钟TTL
          }
        }
      },
      {
        name: 'notification.send',
        routingKey: 'notification.*',
        options: {
          durable: true,
          arguments: {
            'x-dead-letter-exchange': 'zhilink.dlx',
            'x-dead-letter-routing-key': 'notification.failed'
          }
        }
      },
      {
        name: 'analytics.track',
        routingKey: 'analytics.*',
        options: { durable: true }
      }
    ];
    
    for (const queue of queues) {
      await this.channel!.assertQueue(queue.name, queue.options);
      await this.channel!.bindQueue(queue.name, 'zhilink.events', queue.routingKey);
    }
  }
  
  // 发布消息
  async publish(routingKey: string, message: object, options: amqp.Options.Publish = {}): Promise<boolean> {
    if (!this.channel) {
      throw new Error('MQ频道未初始化');
    }
    
    const messageBuffer = Buffer.from(JSON.stringify({
      ...message,
      timestamp: new Date().toISOString(),
      messageId: generateUUID()
    }));
    
    return this.channel.publish('zhilink.events', routingKey, messageBuffer, {
      persistent: true,
      ...options
    });
  }
  
  // 消费消息
  async consume(queueName: string, processor: (message: any) => Promise<void>): Promise<void> {
    if (!this.channel) {
      throw new Error('MQ频道未初始化');
    }
    
    await this.channel.consume(queueName, async (msg) => {
      if (!msg) return;
      
      try {
        const message = JSON.parse(msg.content.toString());
        await processor(message);
        this.channel!.ack(msg);
      } catch (error) {
        console.error(`处理消息失败 [${queueName}]:`, error);
        
        // 重试逻辑
        const retryCount = (msg.properties.headers?.['x-retry-count'] || 0) + 1;
        if (retryCount <= 3) {
          // 延迟重试
          setTimeout(() => {
            this.channel!.publish('zhilink.events', msg.fields.routingKey, msg.content, {
              headers: { 'x-retry-count': retryCount }
            });
          }, retryCount * 1000);
        }
        
        this.channel!.nack(msg, false, false); // 丢弃到死信队列
      }
    });
  }
}

// 推荐生成异步任务处理器
export class RecommendationProcessor {
  constructor(private mqManager: MessageQueueManager) {}
  
  async startProcessing(): Promise<void> {
    await this.mqManager.consume('recommendation.generate', async (message) => {
      const { requirementId, userId } = message;
      
      console.log(`开始生成推荐: 需求${requirementId}, 用户${userId}`);
      
      try {
        // 调用推荐算法
        const recommendations = await this.generateRecommendations(requirementId);
        
        // 缓存推荐结果
        await this.cacheRecommendations(requirementId, recommendations);
        
        // 通知用户推荐已生成
        await this.mqManager.publish('notification.recommendation.ready', {
          userId,
          requirementId,
          recommendationCount: recommendations.length
        });
        
        console.log(`推荐生成完成: 需求${requirementId}, 共${recommendations.length}个推荐`);
      } catch (error) {
        console.error(`推荐生成失败: 需求${requirementId}`, error);
        throw error;
      }
    });
  }
  
  private async generateRecommendations(requirementId: string): Promise<any[]> {
    // 实际的推荐生成逻辑
    // 这里会调用六角色协作推荐引擎
    return [];
  }
  
  private async cacheRecommendations(requirementId: string, recommendations: any[]): Promise<void> {
    // 缓存推荐结果
  }
}
```

---

## 🔐 安全与认证系统

### JWT认证与授权实现
```typescript
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import { Request, Response, NextFunction } from 'express';

export class AuthService {
  private jwtSecret: string;
  private jwtRefreshSecret: string;
  
  constructor() {
    this.jwtSecret = process.env.JWT_SECRET!;
    this.jwtRefreshSecret = process.env.JWT_REFRESH_SECRET!;
  }
  
  // 生成访问令牌
  generateAccessToken(payload: { userId: string; email: string; role: string }): string {
    return jwt.sign(payload, this.jwtSecret, {
      expiresIn: '15m',
      issuer: 'zhilink-platform',
      audience: 'zhilink-client'
    });
  }
  
  // 生成刷新令牌
  generateRefreshToken(payload: { userId: string }): string {
    return jwt.sign(payload, this.jwtRefreshSecret, {
      expiresIn: '7d',
      issuer: 'zhilink-platform',
      audience: 'zhilink-client'
    });
  }
  
  // 验证访问令牌
  verifyAccessToken(token: string): { userId: string; email: string; role: string } | null {
    try {
      const decoded = jwt.verify(token, this.jwtSecret, {
        issuer: 'zhilink-platform',
        audience: 'zhilink-client'
      }) as any;
      
      return {
        userId: decoded.userId,
        email: decoded.email,
        role: decoded.role
      };
    } catch (error) {
      return null;
    }
  }
  
  // 密码加密
  async hashPassword(password: string): Promise<string> {
    const saltRounds = 12;
    return bcrypt.hash(password, saltRounds);
  }
  
  // 密码验证
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }
}

// 认证中间件
export const authMiddleware = (requiredRoles: string[] = []) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const authHeader = req.headers.authorization;
      
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: '缺少有效的认证令牌' });
      }
      
      const token = authHeader.substring(7);
      const authService = new AuthService();
      const payload = authService.verifyAccessToken(token);
      
      if (!payload) {
        return res.status(401).json({ error: '令牌无效或已过期' });
      }
      
      // 角色权限检查
      if (requiredRoles.length > 0 && !requiredRoles.includes(payload.role)) {
        return res.status(403).json({ error: '权限不足' });
      }
      
      // 将用户信息附加到请求对象
      req.user = payload;
      next();
    } catch (error) {
      console.error('认证中间件错误:', error);
      res.status(500).json({ error: '认证服务内部错误' });
    }
  };
};

// API限流中间件
export const rateLimitMiddleware = (limit: number, windowMs: number) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    const identifier = req.ip + ':' + (req.user?.userId || 'anonymous');
    
    const cacheManager = new CacheManager();
    const { allowed, remaining } = await cacheManager.checkRateLimit(
      identifier, 
      limit, 
      Math.floor(windowMs / 1000)
    );
    
    // 设置响应头
    res.set({
      'X-RateLimit-Limit': limit.toString(),
      'X-RateLimit-Remaining': remaining.toString(),
      'X-RateLimit-Reset': new Date(Date.now() + windowMs).toISOString()
    });
    
    if (!allowed) {
      return res.status(429).json({ 
        error: '请求频率过高，请稍后再试',
        retryAfter: Math.ceil(windowMs / 1000)
      });
    }
    
    next();
  };
};

// CORS配置
export const corsOptions = {
  origin: function (origin: string | undefined, callback: Function) {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'];
    
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('不被CORS策略允许的来源'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  maxAge: 86400 // 24小时
};
```

---

## 📊 监控与日志系统

### 应用性能监控配置
```typescript
// 监控服务
import prometheus from 'prom-client';
import winston from 'winston';

export class MonitoringService {
  private static instance: MonitoringService;
  private registry: prometheus.Registry;
  private logger: winston.Logger;
  
  // Prometheus指标
  private httpRequestDuration: prometheus.Histogram<string>;
  private httpRequestTotal: prometheus.Counter<string>;
  private activeConnections: prometheus.Gauge<string>;
  private dbConnectionPool: prometheus.Gauge<string>;
  private recommendationLatency: prometheus.Histogram<string>;
  
  constructor() {
    this.registry = new prometheus.Registry();
    this.setupMetrics();
    this.setupLogger();
  }
  
  static getInstance(): MonitoringService {
    if (!MonitoringService.instance) {
      MonitoringService.instance = new MonitoringService();
    }
    return MonitoringService.instance;
  }
  
  private setupMetrics(): void {
    // HTTP请求持续时间
    this.httpRequestDuration = new prometheus.Histogram({
      name: 'http_request_duration_seconds',
      help: 'HTTP请求持续时间（秒）',
      labelNames: ['method', 'route', 'status_code'],
      buckets: [0.1, 0.5, 1, 2, 5, 10]
    });
    
    // HTTP请求总数
    this.httpRequestTotal = new prometheus.Counter({
      name: 'http_requests_total',
      help: 'HTTP请求总数',
      labelNames: ['method', 'route', 'status_code']
    });
    
    // 活跃连接数
    this.activeConnections = new prometheus.Gauge({
      name: 'active_connections',
      help: '当前活跃连接数'
    });
    
    // 数据库连接池
    this.dbConnectionPool = new prometheus.Gauge({
      name: 'db_connection_pool',
      help: '数据库连接池状态',
      labelNames: ['state'] // idle, active, waiting
    });
    
    // 推荐生成延迟
    this.recommendationLatency = new prometheus.Histogram({
      name: 'recommendation_generation_seconds',
      help: '推荐生成耗时（秒）',
      labelNames: ['algorithm_type'],
      buckets: [1, 5, 10, 30, 60, 120]
    });
    
    // 注册所有指标
    this.registry.registerMetric(this.httpRequestDuration);
    this.registry.registerMetric(this.httpRequestTotal);
    this.registry.registerMetric(this.activeConnections);
    this.registry.registerMetric(this.dbConnectionPool);
    this.registry.registerMetric(this.recommendationLatency);
    
    // 收集默认指标
    prometheus.collectDefaultMetrics({ register: this.registry });
  }
  
  private setupLogger(): void {
    this.logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.errors({ stack: true }),
        winston.format.json()
      ),
      defaultMeta: { service: 'zhilink-platform' },
      transports: [
        new winston.transports.File({ 
          filename: 'logs/error.log', 
          level: 'error',
          maxsize: 10485760, // 10MB
          maxFiles: 5
        }),
        new winston.transports.File({ 
          filename: 'logs/combined.log',
          maxsize: 10485760,
          maxFiles: 10
        }),
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.simple()
          )
        })
      ]
    });
  }
  
  // HTTP请求监控中间件
  httpMetricsMiddleware() {
    return (req: Request, res: Response, next: NextFunction) => {
      const startTime = Date.now();
      
      res.on('finish', () => {
        const duration = (Date.now() - startTime) / 1000;
        const route = req.route?.path || req.path;
        
        this.httpRequestDuration.observe(
          { method: req.method, route, status_code: res.statusCode.toString() },
          duration
        );
        
        this.httpRequestTotal.inc({
          method: req.method,
          route,
          status_code: res.statusCode.toString()
        });
      });
      
      next();
    };
  }
  
  // 记录推荐生成指标
  recordRecommendationLatency(algorithmType: string, durationSeconds: number): void {
    this.recommendationLatency.observe({ algorithm_type: algorithmType }, durationSeconds);
  }
  
  // 更新数据库连接池指标
  updateDbConnectionPool(idle: number, active: number, waiting: number): void {
    this.dbConnectionPool.set({ state: 'idle' }, idle);
    this.dbConnectionPool.set({ state: 'active' }, active);
    this.dbConnectionPool.set({ state: 'waiting' }, waiting);
  }
  
  // 获取指标数据
  async getMetrics(): Promise<string> {
    return this.registry.metrics();
  }
  
  // 日志记录方法
  log(level: string, message: string, meta?: any): void {
    this.logger.log(level, message, meta);
  }
  
  info(message: string, meta?: any): void {
    this.logger.info(message, meta);
  }
  
  error(message: string, error?: Error, meta?: any): void {
    this.logger.error(message, { error: error?.stack, ...meta });
  }
  
  warn(message: string, meta?: any): void {
    this.logger.warn(message, meta);
  }
}

// 健康检查端点
export class HealthCheckService {
  async getHealthStatus(): Promise<{
    status: 'healthy' | 'unhealthy' | 'degraded';
    timestamp: string;
    services: Record<string, any>;
  }> {
    const checks = await Promise.allSettled([
      this.checkDatabase(),
      this.checkRedis(),
      this.checkMessageQueue(),
      this.checkExternalServices()
    ]);
    
    const results = {
      database: checks[0],
      redis: checks[1],
      messageQueue: checks[2],
      externalServices: checks[3]
    };
    
    const failures = checks.filter(check => check.status === 'rejected').length;
    let overallStatus: 'healthy' | 'unhealthy' | 'degraded';
    
    if (failures === 0) {
      overallStatus = 'healthy';
    } else if (failures <= 1) {
      overallStatus = 'degraded';
    } else {
      overallStatus = 'unhealthy';
    }
    
    return {
      status: overallStatus,
      timestamp: new Date().toISOString(),
      services: results
    };
  }
  
  private async checkDatabase(): Promise<{ status: string; responseTime: number }> {
    const start = Date.now();
    try {
      // 执行简单的数据库查询
      await pool.query('SELECT 1');
      return {
        status: 'healthy',
        responseTime: Date.now() - start
      };
    } catch (error) {
      throw {
        status: 'unhealthy',
        error: error.message,
        responseTime: Date.now() - start
      };
    }
  }
  
  private async checkRedis(): Promise<{ status: string; responseTime: number }> {
    const start = Date.now();
    try {
      const redis = new Redis();
      await redis.ping();
      return {
        status: 'healthy',
        responseTime: Date.now() - start
      };
    } catch (error) {
      throw {
        status: 'unhealthy',
        error: error.message,
        responseTime: Date.now() - start
      };
    }
  }
  
  private async checkMessageQueue(): Promise<{ status: string; responseTime: number }> {
    // RabbitMQ健康检查实现
    return { status: 'healthy', responseTime: 10 };
  }
  
  private async checkExternalServices(): Promise<{ status: string; responseTime: number }> {
    // 外部服务健康检查实现
    return { status: 'healthy', responseTime: 50 };
  }
}
```

---

## 🚀 CI/CD部署流水线

### GitHub Actions配置
```yaml
# .github/workflows/deploy.yml
name: Deploy to Kubernetes

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: zhilink/platform

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: zhilink_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Run type checking
      run: npm run type-check
    
    - name: Run linting
      run: npm run lint
    
    - name: Run unit tests
      run: npm run test:unit
      env:
        DATABASE_URL: postgresql://postgres:test@localhost:5432/zhilink_test
        REDIS_URL: redis://localhost:6379
    
    - name: Run integration tests
      run: npm run test:integration
      env:
        DATABASE_URL: postgresql://postgres:test@localhost:5432/zhilink_test
        REDIS_URL: redis://localhost:6379
    
    - name: Generate test coverage
      run: npm run test:coverage
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage/lcov.info

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix=commit-
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: [test, build]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
    
    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBECONFIG }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
    
    - name: Deploy to Kubernetes
      run: |
        export KUBECONFIG=kubeconfig
        export IMAGE_TAG=commit-$(git rev-parse --short HEAD)
        
        # 更新部署配置中的镜像标签
        sed -i "s|image: .*|image: ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}|" k8s/deployment.yaml
        
        # 应用Kubernetes配置
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/secrets.yaml
        kubectl apply -f k8s/deployment.yaml
        kubectl apply -f k8s/service.yaml
        kubectl apply -f k8s/ingress.yaml
        
        # 等待部署完成
        kubectl rollout status deployment/zhilink-platform -n zhilink
        
    - name: Run deployment tests
      run: |
        export KUBECONFIG=kubeconfig
        
        # 等待Pod就绪
        kubectl wait --for=condition=ready pod -l app=zhilink-platform -n zhilink --timeout=300s
        
        # 运行部署后测试
        kubectl run test-pod --image=curlimages/curl --rm -i --restart=Never -n zhilink -- \
          curl -f http://zhilink-platform/health || exit 1
    
    - name: Notify deployment status
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
      if: always()
```

---

**文档维护**: 技术架构团队  
**最后更新**: 2025年8月12日  
**版本控制**: v2.0.0 - 第4轮技术架构实施细节优化版  
**核心价值**: 基于2025年最佳实践构建微服务架构、容器化部署、自动化运维的现代化技术栈，确保智链平台具备高可扩展性、高可用性和高性能